<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }
  </style>
  <style type="text/css">
    a.sourceLine {
      display: inline-block;
      line-height: 1.25;
    }

    a.sourceLine {
      pointer-events: none;
      color: inherit;
      text-decoration: inherit;
    }

    a.sourceLine:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode {
      white-space: pre;
      position: relative;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      code.sourceCode {
        white-space: pre-wrap;
      }

      a.sourceLine {
        text-indent: -1em;
        padding-left: 1em;
      }
    }

    pre.numberSource a.sourceLine {
      position: relative;
      left: -4em;
    }

    pre.numberSource a.sourceLine::before {
      content: attr(title);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      pointer-events: all;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      a.sourceLine::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
</head>

<body>
  <div data-align="center">
    <br /><br /><br /> <img
      src='https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/logo-vim-galore.png'
      alt='vim-galore logo' /> <br /><br /><br /><br />
    <div>
      <pre><code>&lt;a href=&#39;https://github.com/wsdjeg/vim-galore-zh_cn&#39;&gt;Chinese&lt;/a&gt; |
&lt;a href=&#39;http://postd.cc/?s=vim-galore&#39;&gt;Japanese&lt;/a&gt; |
&lt;a href=&#39;https://github.com/lsrdg/vim-galore&#39;&gt;Portuguese&lt;/a&gt; |
&lt;a href=&#39;http://givi.olnd.ru/vim-galore/vim-galore-ru.html&#39;&gt;Russian&lt;/a&gt; |
&lt;a href=&#39;https://github.com/kyoz/vim-galore-vi&#39;&gt;Vietnamese&lt;/a&gt;
&lt;div&gt;
  &lt;br /&gt;
  &lt;sub&gt;Licensed under &lt;a href=&#39;https://creativecommons.org/licenses/by-sa/4.0&#39;&gt;CC BY-SA 4.0&lt;a/&gt;.&lt;/sub&gt;
&lt;/div&gt;</code></pre>
    </div>
    <p><br /><br /></p>
  </div>
  <h3 id="intro"><a href="#intro-1">Intro</a></h3>
  <ul>
    <li><a href="#what-is-vim">What is Vim?</a></li>
    <li><a href="#the-vim-philosophy">The Vim Philosophy</a></li>
    <li><a href="#first-steps">First steps</a></li>
    <li><a href="#minimal-vimrc">Minimal vimrc</a></li>
    <li><a href="#what-kind-of-vim-am-i-running">What kind of Vim am I running?</a></li>
    <li><a href="#cheatsheets">Cheatsheets</a></li>
  </ul>
  <h3 id="basics"><a href="#basics-1">Basics</a></h3>
  <ul>
    <li><a href="#buffers-windows-tabs">Buffers, windows, tabs</a></li>
    <li><a href="#active-loaded-listed-named-buffers">Active, loaded, listed, named buffers</a></li>
    <li><a href="#argument-list">Argument list</a></li>
    <li><a href="#mappings">Mappings</a></li>
    <li><a href="#mapleader">Mapleader</a></li>
    <li><a href="#registers">Registers</a></li>
    <li><a href="#ranges">Ranges</a></li>
    <li><a href="#marks">Marks</a></li>
    <li><a href="#completion">Completion</a></li>
    <li><a href="#motions-operators-text-objects">Motions, operators, text objects</a></li>
    <li><a href="#autocmds">Autocmds</a></li>
    <li><a href="#changelist-jumplist">Changelist, jumplist</a></li>
    <li><a href="#undo-tree">Undo tree</a></li>
    <li><a href="#quickfix-and-location-lists">Quickfix and location lists</a></li>
    <li><a href="#macros">Macros</a></li>
    <li><a href="#colorschemes">Colorschemes</a></li>
    <li><a href="#folding">Folding</a></li>
    <li><a href="#sessions">Sessions</a></li>
    <li><a href="#locality">Locality</a></li>
  </ul>
  <h3 id="usage"><a href="#usage-1">Usage</a></h3>
  <ul>
    <li><a href="#getting-help-offline">Getting help offline</a></li>
    <li><a href="#getting-help-offline-alternative">Getting help offline (alternative)</a></li>
    <li><a href="#getting-help-online">Getting help online</a></li>
    <li><a href="#autocmds-in-practice">Autocmds in practice</a>
      <ul>
        <li><a href="#user-events">User events</a></li>
        <li><a href="#nested-autocmds">Nested autocmds</a></li>
      </ul>
    </li>
    <li><a href="#clipboard">Clipboard</a>
      <ul>
        <li><a href="#clipboard-usage-windows-macos">Clipboard usage (Windows, macOS)</a></li>
        <li><a href="#clipboard-usage-linux-bsd-">Clipboard usage (Linux, BSD, …)</a></li>
      </ul>
    </li>
    <li><a href="#restore-cursor-position-when-opening-file">Restore cursor position when opening file</a></li>
    <li><a href="#temporary-files">Temporary files</a>
      <ul>
        <li><a href="#backup-files">Backup files</a></li>
        <li><a href="#swap-files">Swap files</a></li>
        <li><a href="#undo-files">Undo files</a></li>
        <li><a href="#viminfo-files">Viminfo files</a></li>
        <li><a href="#example-configuration-for-temporary-files">Example configuration for temporary files</a></li>
      </ul>
    </li>
    <li><a href="#editing-remote-files">Editing remote files</a></li>
    <li><a href="#managing-plugins">Managing plugins</a></li>
    <li><a href="#block-insert">Block insert</a></li>
    <li><a href="#running-external-programs-and-using-filters">Running external programs and using filters</a></li>
    <li><a href="#cscope">Cscope</a></li>
    <li><a href="#matchit">MatchIt</a></li>
    <li><a href="#true-colors">True colors</a></li>
  </ul>
  <h3 id="tips"><a href="#tips-1">Tips</a></h3>
  <ul>
    <li><a href="#go-to-other-end-of-selected-text">Go to other end of selected text</a></li>
    <li><a href="#saner-behavior-of-n-and-n">Saner behavior of n and N</a></li>
    <li><a href="#saner-command-line-history">Saner command-line history</a></li>
    <li><a href="#saner-ctrl-l">Saner CTRL-L</a></li>
    <li><a href="#disable-audible-and-visual-bells">Disable audible and visual bells</a></li>
    <li><a href="#quickly-move-current-line">Quickly move current line</a></li>
    <li><a href="#quickly-add-empty-lines">Quickly add empty lines</a></li>
    <li><a href="#quickly-edit-your-macros">Quickly edit your macros</a></li>
    <li><a href="#quickly-jump-to-header-or-source-file">Quickly jump to header or source file</a></li>
    <li><a href="#quickly-change-font-size-in-gui">Quickly change font size in GUI</a></li>
    <li><a href="#change-cursor-style-dependent-on-mode">Change cursor style dependent on mode</a></li>
    <li><a href="#dont-lose-selection-when-shifting-sidewards">Don’t lose selection when shifting sidewards</a></li>
    <li><a href="#reload-a-file-on-saving">Reload a file on saving</a></li>
    <li><a href="#smarter-cursorline">Smarter cursorline</a></li>
    <li><a href="#faster-keyword-completion">Faster keyword completion</a></li>
    <li><a href="#cosmetic-changes-to-colorschemes">Cosmetic changes to colorschemes</a></li>
  </ul>
  <h3 id="commands"><a href="#commands-1">Commands</a></h3>
  <ul>
    <li><a href="#global-and-vglobal">:global and :vglobal</a> - Execute a command on all matching lines.</li>
    <li><a href="#normal-and-execute">:normal and :execute</a> - The scripting dream team.</li>
    <li><a href="#redir-and-execute">:redir and execute()</a> - Capture command output.</li>
  </ul>
  <h3 id="debugging"><a href="#debugging-1">Debugging</a></h3>
  <ul>
    <li><a href="#general-tips">General tips</a></li>
    <li><a href="#verbosity">Verbosity</a></li>
    <li><a href="#profiling-startup-time">Profiling startup time</a></li>
    <li><a href="#profiling-at-runtime">Profiling at runtime</a></li>
    <li><a href="#debugging-vim-scripts">Debugging Vim scripts</a></li>
    <li><a href="#debugging-syntax-files">Debugging syntax files</a></li>
  </ul>
  <h3 id="miscellaneous"><a href="#miscellaneous-1">Miscellaneous</a></h3>
  <ul>
    <li><a href="#additional-resources">Additional resources</a></li>
    <li><a href="#vim-distributions">Vim distributions</a></li>
    <li><a href="#standard-plugins">Standard plugins</a></li>
    <li><a href="#map-capslock-to-control">Map CapsLock to Control</a></li>
    <li><a href="#generating-html-from-buffer">Generating HTML from buffer</a></li>
    <li><a href="#easter-eggs">Easter eggs</a></li>
    <li><a href="#why-hjkl-for-navigation">Why hjkl for navigation?</a></li>
  </ul>
  <h3 id="common-problems"><a href="#common-problems-1">Common problems</a></h3>
  <ul>
    <li><a href="#editing-small-files-is-slow">Editing small files is slow</a></li>
    <li><a href="#editing-huge-files-is-slow">Editing huge files is slow</a></li>
    <li><a href="#bracketed-paste-or-why-do-i-have-to-set-paste-all-the-time">Bracketed paste (or why do I have to set
        ‘paste’ all the time?)</a></li>
    <li><a href="#delays-when-using-escape-key-in-terminal">Delays when using escape key in terminal</a></li>
    <li><a href="#function-search-undo">Function search undo</a></li>
  </ul>
  <h3 id="technical-quirks"><a href="#technical-quirks-1">Technical quirks</a></h3>
  <ul>
    <li><a href="#newline-used-for-nul">Newline used for NUL</a></li>
  </ul>
  <h3 id="terminology"><a href="#terminology-1">Terminology</a></h3>
  <ul>
    <li><a href="#vim-script-vimscript-viml">Vim script? Vimscript? VimL?</a></li>
  </ul>
  <h3 id="list-of-colorschemes"><a href="PLUGINS.md#colorschemes-1">List of colorschemes</a></h3>
  <h3 id="list-of-plugins"><a href="PLUGINS.md">List of plugins</a></h3>
  <p><br></p>
  <h1 id="intro-1">Intro</h1>
  <h2 id="what-is-vim">What is Vim?</h2>
  <p><a href="http://www.vim.org">Vim</a> is a text editor with a long line of ancestors that goes back to <a
      href="https://en.wikipedia.org/wiki/QED_(text_editor)">qed</a>. <a
      href="https://en.wikipedia.org/wiki/Bram_Moolenaar">Bram Moolenaar</a> released it in 1991.</p>
  <p>The project is hosted online at <a href="http://www.vim.org/index.php">vim.org</a>.</p>
  <p>Getting Vim: Use your favourite package manager or visit the <a href="http://www.vim.org/download.php">download
      page</a> from vim.org.</p>
  <p>Discussions and user questions are best done on the <a
      href="https://groups.google.com/forum/#!forum/vim_use">vim_use</a> mailing list or using IRC (<a
      href="https://freenode.net">Freenode</a>) in the <code>#vim</code> channel.</p>
  <p>Development happens on <a href="https://github.com/vim/vim">GitHub</a>, discussions on the <a
      href="https://groups.google.com/forum/#!forum/vim_dev">vim_dev</a> mailing list.</p>
  <p>Read <a href="http://www.viemu.com/a-why-vi-vim.html">Why, oh WHY, do those #?@! nutheads use vi?</a> to see common
    misconceptions about Vim explained.</p>
  <h2 id="the-vim-philosophy">The Vim Philosophy</h2>
  <p>Vim adheres to the modal editing philosophy. This means that it provides multiple modes and the meaning of keys
    changes according to the mode. You navigate files in <em>normal mode</em>, you insert text in <em>insert mode</em>,
    you select lines in <em>visual mode</em>, you access commands in <em>command-line mode</em> and so on. This might
    sound complicated at first, but has a huge advantage: you don’t have to break your fingers by holding several keys
    at once, most of the time you simply press them one after the other. The more common the task, the fewer keys are
    needed.</p>
  <p>A related concept that works well with modal editing are operators and motions. <em>Operators</em> start a certain
    action, e.g. changing, removing, or selecting text. Afterwards you specify the region of text you want to act on
    using a <em>motion</em>. To change everything between parentheses, use <code>ci(</code> (read <em>change inner
      parentheses</em>). To remove an entire paragraph of text, use <code>dap</code> (read <em>delete around
      paragraph</em>).</p>
  <p>If you see advanced Vim users working, you’ll notice that they speak the <em>language of Vim</em> as well as
    pianists handle their instruments. Complex operations are done using only a few key presses. They don’t even think
    about it anymore as <a href="https://en.wikipedia.org/wiki/Muscle_memory">muscle memory</a> took over already. This
    reduces <a href="https://en.wikipedia.org/wiki/Cognitive_load">cognitive load</a> and helps to focus on the actual
    task.</p>
  <h2 id="first-steps">First steps</h2>
  <p>Vim comes bundled with an interactive tutorial that teaches the most basic things you need to know about. You can
    start it from the shell:</p>
  <pre><code>$ vimtutor</code></pre>
  <p>Don’t be put off by how boring it looks like and work through the exercises. The editors or IDEs you used before
    were most probably all non-modal, so working by switching modes will seem awkward at first, but the more you use
    Vim, the more it becomes <a href="https://en.wikipedia.org/wiki/Muscle_memory">muscle memory</a>.</p>
  <p>Vim was bolted on <a href="https://en.wikipedia.org/wiki/Stevie_(text_editor)">Stevie</a>, a <a
      href="https://en.wikipedia.org/wiki/Vi">vi</a> clone, and supports two operating modes: “compatible” and
    “nocompatible”. Using Vim in compatible mode means using vi defaults for all options, opposed to Vim defaults. As
    long as you didn’t create a user vimrc yet or started Vim with <code>vim -N</code>, compatible mode is assumed!
    Don’t use Vim in compatible mode. Just don’t.</p>
  <p>Next steps:</p>
  <ol type="1">
    <li>Create your own <a href="#minimal-vimrc">vimrc</a>.</li>
    <li>Have some <a href="#cheatsheets">cheatsheets</a> ready for the first weeks.</li>
    <li>Read through the <a href="#basics-1">basics</a> section to learn what is even possible.</li>
    <li>Learn on demand! You never finish learning Vim. If you encounter any problems, just look for it on the internet.
      Your problem was solved already. Vim comes with great documentation and knowing how to navigate it is a must: <a
        href="#getting-help-offline">Getting help offline</a>.</li>
    <li>Have a look at the <a href="#additional-resources">additional resources</a>.</li>
  </ol>
  <p>One last advice: Please learn how to use Vim properly before starting to add all kinds of hyped <a
      href="#managing-plugins">plugins</a> that only implement features that Vim already supports natively.</p>
  <h2 id="minimal-vimrc">Minimal vimrc</h2>
  <p>The user vimrc can be put into <code>~/.vimrc</code> or for the sake of better separation into
    <code>~/.vim/vimrc</code>. The latter makes it easy to put the entire configuration under version control and upload
    it to, let’s say GitHub.</p>
  <p>You find many “minimal vimrcs” all over the net, and maybe my version isn’t as minimal as it should be, but it
    provides a good set of sane settings that I deem to be useful for starting out.</p>
  <p>Eventually you have to read up on all the mentioned settings anyway and decide for yourself. :-)</p>
  <p>So here it is: <a href="static/minimal-vimrc.vim">minimal-vimrc</a></p>
  <p>In case you’re interested, here’s <a href="https://github.com/mhinz/dotfiles/blob/master/.vim/vimrc">my vimrc</a>.
  </p>
  <p><strong>TIP</strong>: Most plugin authors maintain several plugins and also publish their vimrc on GitHub (often in
    a repository called “vim-config” or “dotfiles”), so whenever you find a plugin you like, look up its maintainer’s
    GitHub page and look through the repositories.</p>
  <h2 id="what-kind-of-vim-am-i-running">What kind of Vim am I running?</h2>
  <p>Looking at <code>:version</code> will give you all the information you need to know about how the currently running
    Vim binary was compiled.</p>
  <p>The first line tells you when the binary was compiled and the version, e.g. 7.4. One of the next lines states
    <code>Included patches: 1-1051</code>, which is the patch level. Thus, your exact Vim version is 7.4.1051.</p>
  <p>Another line states something like <code>Tiny version without GUI</code> or <code>Huge version with GUI</code>. The
    obvious information from that is whether your Vim includes GUI support, e.g. for starting <code>gvim</code> from the
    shell or running <code>:gui</code> from Vim within a terminal emulator. The other important information is the
    <code>Tiny</code> and <code>Huge</code>. Vim distinguishes between feature sets called <code>tiny</code>,
    <code>small</code>, <code>normal</code>, <code>big</code>, and <code>huge</code>, all enabling different subsets of
    features.</p>
  <p>The majority of <code>:version</code> output is consumed by the feature list itself. <code>+clipboard</code> means
    the clipboard feature was compiled in, <code>-clipboard</code> means it wasn’t compiled in.</p>
  <p>A few Vim features need to be compiled in for them to work. E.g. for <code>:prof</code> to work, you need a Vim
    with a huge feature set, because that set enables the <code>+profile</code> feature.</p>
  <p>If that’s not the case and you installed Vim from a package manager, make sure to install a package called
    <code>vim-x</code>, <code>vim-x11</code>, <code>vim-gtk</code>, <code>vim-gnome</code> or similar, since these
    packages usually come with the huge feature set.</p>
  <p>You can also test for the version or features programmatically:</p>
  <pre class="vim"><code>&quot; Do something if running at least Vim 7.4.42 with +profile enabled.
if (v:version &gt; 704 || v:version == 704 &amp;&amp; has(&#39;patch42&#39;)) &amp;&amp; has(&#39;profile&#39;)
  &quot; do stuff
endif</code></pre>
  <p>Help:</p>
  <pre><code>:h :version
:h feature-list
:h +feature-list
:h has-patch</code></pre>
  <h2 id="cheatsheets">Cheatsheets</h2>
  <ul>
    <li>http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png</li>
    <li>https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png</li>
    <li>http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png</li>
    <li>http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png</li>
  </ul>
  <p>Or quickly open a cheatsheet from within Vim: <a href="https://github.com/lifepillar/vim-cheat40">vim-cheat40</a>.
  </p>
  <h1 id="basics-1">Basics</h1>
  <h2 id="buffers-windows-tabs">Buffers, windows, tabs</h2>
  <p>Vim is a text editor. Every time text is shown, the text is part of a <strong>buffer</strong>. Each file will be
    opened in its own buffer. Plugins show stuff in their own buffers etc.</p>
  <p>Buffers have many attributes, e.g. whether the text it contains is modifiable, or whether it is associated with a
    file and thus needs to be synchronized to disk on saving.</p>
  <p><strong>Windows</strong> are viewports <em>onto</em> buffers. If you want to view several files at the same time or
    even different locations of the same file, you use windows.</p>
  <p>And please, please don’t call them <em>splits</em>. You can split a window in two, but that doesn’t make them
    <em>splits</em>.</p>
  <p>Windows can be split vertically or horizontally and the heights and widths of existing windows can be altered, too.
    Therefore, you can use whatever window layout you prefer.</p>
  <p>A <strong>tab page</strong> (or just tab) is a collection of windows. Thus, if you want to use multiple window
    layouts, use tabs.</p>
  <p>Putting it in a nutshell, if you start Vim without arguments, you’ll have one tab page that holds one window that
    shows one buffer.</p>
  <p>By the way, the buffer list is global and you can access any buffer from any tab.</p>
  <h2 id="active-loaded-listed-named-buffers">Active, loaded, listed, named buffers</h2>
  <p>Run Vim like this <code>vim file1</code>. The file’s content will be loaded into a buffer. You have a
    <strong>loaded buffer</strong> now. The content of the buffer is only synchronized to disk (written back to the
    file) if you save it within Vim.</p>
  <p>Since the buffer is also shown in a window, it’s also an <strong>active buffer</strong>. Now if you load another
    file via <code>:e file2</code>, <code>file1</code> will become a <strong>hidden buffer</strong> and
    <code>file2</code> the active one.</p>
  <p>Both buffers are also <strong>listed</strong>, thus they will get listed in the output of <code>:ls</code>. Plugin
    buffers or help buffers are often marked as unlisted, since they’re not regular files you usually edit with a text
    editor. Listed and unlisted buffers can be shown via <code>:ls!</code>.</p>
  <p><strong>Unnamed buffers</strong>, also often used by plugins, are buffers that don’t have an associated filename.
    E.g. <code>:enew</code> will create an unnamed scratch buffer. Add some text and write it to disk via
    <code>:w /tmp/foo</code>, and it will become a named buffer.</p>
  <h2 id="argument-list">Argument list</h2>
  <p>The <a href="#buffers-windows-tabs">global buffer list</a> is a Vim thing. Before that, in vi, there only used to
    be the argument list, which is also available in Vim.</p>
  <p>Every filename given to Vim on the shell command-line, is remembered in the argument list. There can be multiple
    argument lists: by default all arguments are put into the global argument list, but you can use
    <code>:arglocal</code> to create a new argument list that is local to the window.</p>
  <p>List the current arguments with <code>:args</code>. Switch between files from the argument list with
    <code>:next</code>, <code>:previous</code>, <code>:first</code>, <code>:last</code> and friends. Alter it with
    <code>:argadd</code>, <code>:argdelete</code> or <code>:args</code> with a list of files.</p>
  <p>If you should prefer using the buffer or argument list for working with files is a matter of taste. My impression
    is that most people use the buffer list exclusively.</p>
  <p>Nevertheless, there is one huge use case for the argument list: batch processing via <code>:argdo</code>! A simple
    refactoring example:</p>
  <pre class="vim"><code>:args **/*.[ch]
:argdo %s/foo/bar/ge | update</code></pre>
  <p>This replaces all occurrences of “foo” by “bar” in all C source and header files from the current directory and
    below.</p>
  <p>Help: <code>:h argument-list</code></p>
  <h2 id="mappings">Mappings</h2>
  <p>You can define your own mappings with the <code>:map</code> family of commands. Each command of that family defines
    a mapping for a certain set of modes. Technically Vim comes with a whopping 12 modes, 6 of them can be mapped.
    Additionally, some commands act on multiple modes at once.</p>
  <table>
    <thead>
      <tr class="header">
        <th>Recursive</th>
        <th>Non-recursive</th>
        <th>Unmap</th>
        <th>Modes</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>:map</code></td>
        <td><code>:noremap</code></td>
        <td><code>:unmap</code></td>
        <td>normal, visual, operator-pending</td>
      </tr>
      <tr class="even">
        <td><code>:nmap</code></td>
        <td><code>:nnoremap</code></td>
        <td><code>:nunmap</code></td>
        <td>normal</td>
      </tr>
      <tr class="odd">
        <td><code>:xmap</code></td>
        <td><code>:xnoremap</code></td>
        <td><code>:xunmap</code></td>
        <td>visual</td>
      </tr>
      <tr class="even">
        <td><code>:cmap</code></td>
        <td><code>:cnoremap</code></td>
        <td><code>:cunmap</code></td>
        <td>command-line</td>
      </tr>
      <tr class="odd">
        <td><code>:omap</code></td>
        <td><code>:onoremap</code></td>
        <td><code>:ounmap</code></td>
        <td>operator-pending</td>
      </tr>
      <tr class="even">
        <td><code>:imap</code></td>
        <td><code>:inoremap</code></td>
        <td><code>:iunmap</code></td>
        <td>insert</td>
      </tr>
    </tbody>
  </table>
  <p>E.g. this defines the mapping for normal mode only:</p>
  <pre class="vim"><code>:nmap &lt;space&gt; :echo &quot;foo&quot;&lt;cr&gt;</code></pre>
  <p>Unmap it again by using <code>:nunmap &lt;space&gt;</code>.</p>
  <p>For a few more but rather uncommon modes (or combinations of them), see <code>:h map-modes</code>.</p>
  <p>So far, so good. There’s only one problem that can be pretty confusing to beginners: <code>:nmap</code> is
    <em>recursive</em>! That is, the right-hand side takes other mappings into account.</p>
  <p>So you defined a mapping that simply echoes “Foo”:</p>
  <pre class="vim"><code>:nmap b :echo &quot;Foo&quot;&lt;cr&gt;</code></pre>
  <p>But what if you want to map the default behavior of <code>b</code> (going one word back) to another key?</p>
  <pre class="vim"><code>:nmap a b</code></pre>
  <p>If you hit <kbd>a</kbd>, we expect the cursor to go back a word, but instead “Foo” is printed in the command-line!
    Because the right-hand side, <code>b</code>, was mapped to another action already, namely
    <code>:echo "Foo"&lt;cr&gt;</code>.</p>
  <p>The proper way to resolve this problem is to use a <em>non-recursive</em> mapping instead:</p>
  <pre class="vim"><code>:nnoremap a b</code></pre>
  <p>Rule of thumb: Always use non-recursive mappings unless recursing is actually desired.</p>
  <p>Look up your mappings by not giving a right-hand side. E.g. <code>:nmap</code> shows all normal mappings and
    <code>:nmap &lt;leader&gt;</code> shows all normal mappings that start with the mapleader.</p>
  <p>If you want to disable a standard mapping, map them to the special <code>&lt;nop&gt;</code> character,
    e.g. <code>:noremap &lt;left&gt; &lt;nop&gt;</code>.</p>
  <p>Help:</p>
  <pre><code>:h key-notation
:h mapping
:h 05.3</code></pre>
  <h2 id="mapleader">Mapleader</h2>
  <p>The mapleader is simply a placeholder than can be used with custom mappings and is set to <code>\</code> by
    default.</p>
  <pre class="vim"><code>nnoremap &lt;leader&gt;h :helpgrep&lt;space&gt;</code></pre>
  <p>This mapping is triggered by <code>\h</code>. If you want to use <code>&lt;space&gt;h</code> instead:</p>
  <pre class="vim"><code>let mapleader = &#39; &#39;
nnoremap &lt;leader&gt;h :helpgrep&lt;space&gt;</code></pre>
  <p>Moreover, there is <code>&lt;localleader&gt;</code> that is the local counterpart to <code>&lt;leader&gt;</code>
    and is supposed to be used for mappings that are local to the buffer, eg. filetype-specific plugins. It also
    defaults to <code>\</code>.</p>
  <p><strong>Note</strong>: Set the mapleaders before mappings! All leader mappings that are in effect already, won’t
    change just because the mapleader was changed. <code>:nmap &lt;leader&gt;</code> will show all normal mode leader
    mappings with the mapleader resolved already, so use it to double-check your mappings.</p>
  <p>See <code>:h mapleader</code> and <code>:h maplocalleader</code> for more.</p>
  <h2 id="registers">Registers</h2>
  <p>Registers are slots that save text. Copying text into a register is called <strong>yanking</strong> and extracting
    text from a register is called <strong>pasting</strong>.</p>
  <p>Vim provides the following registers:</p>
  <table>
    <colgroup>
      <col style="width: 23%" />
      <col style="width: 26%" />
      <col style="width: 13%" />
      <col style="width: 12%" />
      <col style="width: 23%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Type</th>
        <th>Character</th>
        <th>Filled by?</th>
        <th>Readonly?</th>
        <th>Contains text from?</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>Unnamed</td>
        <td><code>"</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>Last yank or deletion. (<code>d</code>, <code>c</code>, <code>s</code>, <code>x</code>, <code>y</code>)</td>
      </tr>
      <tr class="even">
        <td>Numbered</td>
        <td><code>0</code> to <code>9</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>Register <code>0</code>: Last yank. Register <code>1</code>: Last deletion. Register <code>2</code>: Second
          last deletion. And so on. Think of registers <code>1</code>-<code>9</code> as a read-only <a
            href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">queue</a> with 9 elements.</td>
      </tr>
      <tr class="odd">
        <td>Small delete</td>
        <td><code>-</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>Last deletion that was less than one line.</td>
      </tr>
      <tr class="even">
        <td>Named</td>
        <td><code>a</code> to <code>z</code>, <code>A</code> to <code>Z</code></td>
        <td>user</td>
        <td>[ ]</td>
        <td>If you yank to register <code>a</code>, you replace its text. If you yank to register <code>A</code>, you
          append to the text in register <code>a</code>.</td>
      </tr>
      <tr class="odd">
        <td>Read-only</td>
        <td><code>:</code>, <code>.</code>, <code>%</code></td>
        <td>vim</td>
        <td>[x]</td>
        <td><code>:</code>: Last command, <code>.</code>: Last inserted text, <code>%</code>: Current filename.</td>
      </tr>
      <tr class="even">
        <td>Alternate buffer</td>
        <td><code>#</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>Most of the time the previously visited buffer of the current window. See <code>:h alternate-file</code>
        </td>
      </tr>
      <tr class="odd">
        <td>Expression</td>
        <td><code>=</code></td>
        <td>user</td>
        <td>[ ]</td>
        <td>Evaluation of the VimL expression that was yanked. E.g. do this in insert mode:
          <code>&lt;c-r&gt;=5+5&lt;cr&gt;</code> and “10” will be inserted in the buffer.</td>
      </tr>
      <tr class="even">
        <td>Selection</td>
        <td><code>+</code>, <code>*</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td><code>*</code> and <code>+</code> are the <a href="#clipboard">clipboard</a> registers.</td>
      </tr>
      <tr class="odd">
        <td>Drop</td>
        <td><code>~</code></td>
        <td>vim</td>
        <td>[x]</td>
        <td>From last drag’n’drop.</td>
      </tr>
      <tr class="even">
        <td>Black hole</td>
        <td><code>_</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>If you don’t want any other registers implicitly affected. E.g. <code>"_dd</code> deletes the current line
          without affecting registers <code>"</code>, <code>1</code>, <code>+</code>, <code>*</code>.</td>
      </tr>
      <tr class="odd">
        <td>Last search pattern</td>
        <td><code>/</code></td>
        <td>vim</td>
        <td>[ ]</td>
        <td>Last pattern used with <code>/</code>, <code>?</code>, <code>:global</code>, etc.</td>
      </tr>
    </tbody>
  </table>
  <p>Each register that is not readonly can be set by the user:</p>
  <pre class="vim"><code>:let @/ = &#39;register&#39;</code></pre>
  <p>Afterwards <kbd>n</kbd> would jump to the next occurrence of “register”.</p>
  <p>There are numerous exceptions when registers get implicitly filled, so be sure to read <code>:h registers</code>.
  </p>
  <p>Yank with <code>y</code> and paste with <code>p</code>/<code>P</code>, but mind that Vim distinguishes between
    characterwise and linewise visual selections. See <code>:h linewise</code>.</p>
  <p><strong>Example: linewise</strong></p>
  <p><code>yy</code> (or just <code>Y</code>) yanks the current line, move the cursor somewhere else, use <code>p</code>
    to paste below the current line <code>P</code> for pasting above it.</p>
  <p><strong>Example: charwise</strong></p>
  <p>Yank the first word with <code>0yw</code>, move somewhere else, paste after the cursor on the current line with
    <code>p</code> and before the cursor with <code>P</code>.</p>
  <p><strong>Example: explicit naming of register</strong></p>
  <p><code>"aY</code> yanks the current line into register <code>a</code>. Move to another line. <code>"AY</code>
    appends the current line to register <code>a</code>.</p>
  <p>I suggest playing around with all these registers a bit and constantly checking <code>:reg</code>, so you can see
    what’s actually happening.</p>
  <p><strong>Fun fact</strong>: In Emacs “yanking” stands for pasting (or <em>reinserting previously killed text</em>)
    not copying.</p>
  <h2 id="ranges">Ranges</h2>
  <p>Ranges are pretty easy to understand, but many Vimmers don’t know about their full potential.</p>
  <ul>
    <li>Many commands take ranges.</li>
    <li>An address denotes a certain line.</li>
    <li>A range is either a single address or a pair of addresses separated by either <code>,</code> or <code>;</code>.
    </li>
    <li>Ranges tell commands which lines to act on.</li>
    <li>Most commands act only on the current line by default. Notable exceptions are <code>:write</code> and
      <code>:global</code> which act on all lines.</li>
  </ul>
  <p>The usage of ranges is pretty intuitive, so here are some examples (using <code>:d</code> as short form of
    <code>:delete</code>):</p>
  <table>
    <colgroup>
      <col style="width: 36%" />
      <col style="width: 64%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Command</th>
        <th>Lines acted on</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>:d</code></td>
        <td>Current line.</td>
      </tr>
      <tr class="even">
        <td><code>:.d</code></td>
        <td>Current line.</td>
      </tr>
      <tr class="odd">
        <td><code>:1d</code></td>
        <td>First line.</td>
      </tr>
      <tr class="even">
        <td><code>:$d</code></td>
        <td>Last line.</td>
      </tr>
      <tr class="odd">
        <td><code>:1,$d</code></td>
        <td>All lines.</td>
      </tr>
      <tr class="even">
        <td><code>:%d</code></td>
        <td>All lines (syntactic sugar for <code>1,$</code>).</td>
      </tr>
      <tr class="odd">
        <td><code>:.,5d</code></td>
        <td>Current line to line 5.</td>
      </tr>
      <tr class="even">
        <td><code>:,5d</code></td>
        <td>Also current line to line 5.</td>
      </tr>
      <tr class="odd">
        <td><code>:,+3d</code></td>
        <td>Current line and the next 3 lines.</td>
      </tr>
      <tr class="even">
        <td><code>:1,+3d</code></td>
        <td>First line to current line + 3.</td>
      </tr>
      <tr class="odd">
        <td><code>:,-3d</code></td>
        <td>Current line and the last 3 lines. (Vim will prompt you, since this is a reversed range.)</td>
      </tr>
      <tr class="even">
        <td><code>:3,'xdelete</code></td>
        <td>Lines 3 to the line marked by <a href="#marks">mark</a> x.</td>
      </tr>
      <tr class="odd">
        <td><code>:/^foo/,$delete</code></td>
        <td>From the next line that starts with “foo” to the end.</td>
      </tr>
      <tr class="even">
        <td><code>:/^foo/+1,$delete</code></td>
        <td>From the line after the line that starts with “foo” to the end.</td>
      </tr>
    </tbody>
  </table>
  <p>Note that instead of <code>,</code>, <code>;</code> can be used as a separator. The difference is that in the case
    of <code>from,to</code>, the <em>to</em> is relative to the current line, but when using <code>from;to</code>, the
    <em>to</em> is relative to the address of <em>from</em>! Assuming you’re on line 5, <code>:1,+1d</code> would delete
    lines 1 to 6, whereas <code>:1;+1d</code> would only delete lines 1 and 2.</p>
  <p>The <code>/</code> address can be preceded with another address. This allows you to <em>stack</em> patterns, e.g.:
  </p>
  <pre class="vim"><code>:/foo//bar//quux/d</code></pre>
  <p>This would delete the first line containing “quux” after the first line containing “bar” after the first line
    containing “foo” after the current line.</p>
  <p>Sometimes Vim automatically prepends the command-line with a range. E.g. start a visual line selection with
    <code>V</code>, select some lines and type <code>:</code>. The command-line will be populated with the range
    <code>'&lt;,'&gt;</code>, which means the following command will use the previously selected lines as a range. (This
    is also why you sometimes see mappings like <code>:vnoremap foo :&lt;c-u&gt;command</code>. Here
    <code>&lt;c-u&gt;</code> is used to remove the range, because Vim will throw an error when giving a range to a
    command that doesn’t support it.)</p>
  <p>Another example is using <code>!!</code> in normal mode. This will populate the command-line with <code>:.!</code>.
    If followed by an external program, that program’s output would replace the current line. So you could replace the
    current paragraph with the output of ls by using <code>:?^$?+1,/^$/-1!ls</code>. Fancy!</p>
  <p>Help:</p>
  <pre><code>:h cmdline-ranges
:h 10.3</code></pre>
  <h2 id="marks">Marks</h2>
  <p>You use marks to remember a position, that is line number and column, in a file.</p>
  <table>
    <colgroup>
      <col style="width: 29%" />
      <col style="width: 41%" />
      <col style="width: 29%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Marks</th>
        <th>Set by..</th>
        <th>Usage</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>a</code> - <code>z</code></td>
        <td>User</td>
        <td>Local to file, thus only valid within one file. Jumping to a lowercase mark, means jumping within the
          current file.</td>
      </tr>
      <tr class="even">
        <td><code>A</code> - <code>Z</code></td>
        <td>User</td>
        <td>Global, thus valid between files. Also called <em>file marks</em>. Jumping to a file mark may switch to
          another buffer.</td>
      </tr>
      <tr class="odd">
        <td><code>0</code> - <code>9</code></td>
        <td>viminfo</td>
        <td><code>0</code> is the position when the viminfo file was written last. In practice this means when the last
          Vim process ended. <code>1</code> is the position of when the second last Vim process ended and so on.</td>
      </tr>
    </tbody>
  </table>
  <p>Put <code>'</code>/<code>g'</code> or <code>`</code>/<code>g`</code> in front of a mark to form a motion.</p>
  <p>Use <code>mm</code> to remember the current position with mark “m”. Move around the file and then jump back via
    <code>'m</code> (first non-blank) or <code>`m</code> (exact column). Lowercase marks will be remembered after
    exiting Vim, if you tell your viminfo file to do so, see <code>:h viminfo-'</code>.</p>
  <p>Use <code>mM</code> to remember the current position with file mark “M”. Switch to another buffer and switch back
    via <code>'M</code> or <code>`M</code>.</p>
  <p>Other motions include:</p>
  <table>
    <thead>
      <tr class="header">
        <th>Motion</th>
        <th>Jump to..</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>'[</code>, <code>`[</code></td>
        <td>First line or character of previously changed or yanked text.</td>
      </tr>
      <tr class="even">
        <td><code>']</code>, <code>`]</code></td>
        <td>Last line or character of previously changed or yanked text.</td>
      </tr>
      <tr class="odd">
        <td><code>'&lt;</code>, <code>`&lt;</code></td>
        <td>Beginning line or character of last visual selection.</td>
      </tr>
      <tr class="even">
        <td><code>'&gt;</code>, <code>`&gt;</code></td>
        <td>Ending line or character of last visual selection.</td>
      </tr>
      <tr class="odd">
        <td><code>''</code>, <code>``</code></td>
        <td>Position before the latest jump.</td>
      </tr>
      <tr class="even">
        <td><code>'"</code>, <code>`"</code></td>
        <td>Position when last exiting the current buffer.</td>
      </tr>
      <tr class="odd">
        <td><code>'^</code>, <code>`^</code></td>
        <td>Position where last insertion stopped.</td>
      </tr>
      <tr class="even">
        <td><code>'.</code>, <code>`.</code></td>
        <td>Position where last change was made.</td>
      </tr>
      <tr class="odd">
        <td><code>'(</code>, <code>`(</code></td>
        <td>Start of current sentence.</td>
      </tr>
      <tr class="even">
        <td><code>')</code>, <code>`)</code></td>
        <td>End of current sentence.</td>
      </tr>
      <tr class="odd">
        <td><code>'{</code>, <code>`{</code></td>
        <td>Start of current paragraph.</td>
      </tr>
      <tr class="even">
        <td><code>'}</code>, <code>`}</code></td>
        <td>End of current paragraph.</td>
      </tr>
    </tbody>
  </table>
  <p>Marks can also be used in a <a href="#ranges">range</a>. You probably saw this before and wondered what it means:
    Select some text in visual mode and do <code>:</code>, the command-line will be prepended with
    <code>:'&lt;,'&gt;</code>, which means the following command would get a range that denotes the visual selection.
  </p>
  <p>Use <code>:marks</code> to list all marks. Read everything in <code>:h mark-motions</code>.</p>
  <h2 id="completion">Completion</h2>
  <p>Vim provides many kinds of insert mode completions. If there are multiple matches, a popup menu will let you
    navigate to the match of your choice.</p>
  <p>Typical kinds of completion are tags, functions from imported modules or libraries, file names, dictionary or
    simply words from the current buffer.</p>
  <p>Vim provides a mapping for each kind of completion and they all start with <code>&lt;c-x&gt;</code> (remember to
    use them in insert mode):</p>
  <table>
    <thead>
      <tr class="header">
        <th>Mapping</th>
        <th>Kind</th>
        <th>Help</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-l&gt;</code></td>
        <td>whole lines</td>
        <td><code>:h i^x^l</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;&lt;c-n&gt;</code></td>
        <td>keywords from current file</td>
        <td><code>:h i^x^n</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-k&gt;</code></td>
        <td>keywords from <code>'dictionary'</code> option</td>
        <td><code>:h i^x^k</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;&lt;c-t&gt;</code></td>
        <td>keywords from <code>'thesaurus'</code> option</td>
        <td><code>:h i^x^t</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-i&gt;</code></td>
        <td>keywords from current and included files</td>
        <td><code>:h i^x^i</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;&lt;c-]&gt;</code></td>
        <td>tags</td>
        <td><code>:h i^x^]</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-f&gt;</code></td>
        <td>file names</td>
        <td><code>:h i^x^f</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;&lt;c-d&gt;</code></td>
        <td>definitions or macros</td>
        <td><code>:h i^x^d</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-v&gt;</code></td>
        <td>Vim commands</td>
        <td><code>:h i^x^v</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;&lt;c-u&gt;</code></td>
        <td>user defined (as specified in <code>'completefunc'</code>)</td>
        <td><code>:h i^x^u</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;c-x&gt;&lt;c-o&gt;</code></td>
        <td>omni completion (as specified in <code>'omnifunc'</code>)</td>
        <td><code>:h i^x^o</code></td>
      </tr>
      <tr class="even">
        <td><code>&lt;c-x&gt;s</code></td>
        <td>spelling suggestions</td>
        <td><code>:h i^Xs</code></td>
      </tr>
    </tbody>
  </table>
  <p>People might be confused about the difference between user defined completion and omni completion, but technically
    they do the same thing. They take a function that inspects the current position and return a list of suggestions.
    User defined completion is defined by the user for their own personal purposes. (Surprise!) It could be anything.
    Omni completion is meant for filetype-specific purposes, like completing struct members or class methods, and is
    often set by filetype plugins.</p>
  <p>Vim also allows for completing multiple kinds at once by setting the <code>'complete'</code> option. By default
    that option includes quite a lot, so be sure to trim it to your taste. You can trigger this completion by using
    either <code>&lt;c-n&gt;</code> (next) and <code>&lt;c-p&gt;</code> (previous), which also happen to be the keys
    used for choosing entries in the popup menu. See <code>:h i^n</code> and <code>:h 'complete'</code> for more on
    this.</p>
  <p>Be sure to check out <code>:h 'completeopt'</code> for configuring the behaviour of the popup menu. The default is
    quite sane, but I prefer adding “noselect” as well.</p>
  <p>Help:</p>
  <pre><code>:h ins-completion
:h popupmenu-keys
:h new-omni-completion</code></pre>
  <h2 id="motions-operators-text-objects">Motions, operators, text objects</h2>
  <p><strong>Motions</strong> move the cursor. You all know <code>h</code>/<code>j</code>/<code>k</code>/<code>l</code>.
    Or <code>w</code> and <code>b</code>. Even <code>/</code> is a motion. They also take a count.
    <code>2?the&lt;cr&gt;</code> jumps to the second last occurrence of “the”.</p>
  <p>See <code>:h navigation</code> and everything below for all available motions.</p>
  <p><strong>Operators</strong> act on a region of text, e.g. <code>d</code>, <code>~</code>, <code>gU</code>,
    <code>&gt;</code> to name just a few. They get used in two contexts, either in normal or visual mode. In normal
    mode, operators come first followed by a motion, e.g. <code>&gt;j</code>. In visual mode, operators simply act on
    the selection, e.g. <code>Vjd</code>.</p>
  <p>Like motions, operators take a count, e.g. <code>2gUw</code> makes the rest of the current word and the next one
    uppercase. Since motions and operators take counts, <code>2gU2w</code> works just as well and executes
    <code>gU2w</code> twice.</p>
  <p>See <code>:h operator</code> for all available operators. Use <code>:set tildeop</code> to make <code>~</code> act
    as an operator.</p>
  <p><strong>Text objects</strong> act on the surrounding area, opposed to motions that act into one direction. Actually
    they work on objects, e.g. a whole word, a whole sentence, everything between parentheses, and so on.</p>
  <p>Text objects can’t be used to move the cursor in normal mode, because even the most-skilled cursors can’t jump into
    two directions at the same time. It works in visual mode though, because then one side of the object is already
    selected and the cursor simply jumps to the other side.</p>
  <p>Text objects start with either <code>i</code> (think <em>inner</em>) or <code>a</code> (think <em>around</em>)
    followed by a character denoting the object. With <code>i</code> it only acts on the object itself, with
    <code>a</code> on the object plus trailing whitespace. E.g. <code>diw</code> deletes the current word and
    <code>ci(</code> changes everything between parentheses.</p>
  <p>Text objects take a count. Imagine <code>((( )))</code> and the cursor on or between the most inner parentheses,
    then <code>d2a(</code> will remove the 2 inner pairs of parentheses and everything in between.</p>
  <p>See <code>:h text-objects</code> for all available text objects.</p>
  <h2 id="autocmds">Autocmds</h2>
  <p>You can trigger an action after many events in Vim, such as a buffer being saved or Vim having started up, by
    so-called <em>autocmds</em>.</p>
  <p>Vim relies extensively on autocmds. Don’t believe me? Check <code>:au</code>, but don’t let the output overwhelm
    you. These are all the autocmds that are in effect right now!</p>
  <p>See <code>:h {event}</code> for a quick overview of all available events and <code>:h autocmd-events-abc</code> for
    more details.</p>
  <p>A typical example would be filetype-specific settings:</p>
  <pre class="vim"><code>autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:#</code></pre>
  <p>But how does a buffer even know that it contains Ruby code? Because another autocmd detected it as that and set the
    filetype accordingly which again triggered the <code>FileType</code> event.</p>
  <p>One of the first things everyone adds to their vimrc is <code>filetype on</code>. This simply means that
    <code>filetype.vim</code> is read at startup which sets autocmds for almost all filetypes under the sun.</p>
  <p>If you’re brave enough, have a look at it: <code>:e $VIMRUNTIME/filetype.vim</code>. Search for “Ruby” and you’ll
    find that Vim simply uses the file extension <code>.rb</code> to detect Ruby files:</p>
  <p><strong>NOTE</strong>: Autocmds of the same event are executed in the order they were created. <code>:au</code>
    shows them in the correct order.</p>
  <pre class="vim"><code>au BufNewFile,BufRead *.rb,*.rbw  setf ruby</code></pre>
  <p>The <code>BufNewFile</code> and <code>BufRead</code> events in this case are hardcoded in the C sources of Vim and
    get emitted every time you open a file via <code>:e</code> and similar commands. Afterwards all the hundreds of
    filetypes from <code>filetype.vim</code> are tested for.</p>
  <p>Putting it in a nutshell, Vim makes heavy use of events and autocmds but also exposes a clean interface to hook
    into that event-driven system for customization.</p>
  <p>Help: <code>:h autocommand</code></p>
  <h2 id="changelist-jumplist">Changelist, jumplist</h2>
  <p>The positions of the last 100 changes are kept in the <strong>changelist</strong>. Several small changes on the
    same line will be merged together, but the position will be that of the last change nevertheless (in case you added
    something in the middle of the line).</p>
  <p>Every time you jump, the position <em>before</em> the jump is remembered in the <strong>jumplist</strong>. A
    jumplist has up to 100 entries. Each window has its own jumplist. When you split a window, the jumplist is copied.
  </p>
  <p>A jump is one of the following commands: <code>'</code>, <code>`</code>, <code>G</code>, <code>/</code>,
    <code>?</code>, <code>n</code>, <code>N</code>, <code>%</code>, <code>(</code>, <code>)</code>, <code>[[</code>,
    <code>]]</code>, <code>{</code>, <code>}</code>, <code>:s</code>, <code>:tag</code>, <code>L</code>, <code>M</code>,
    <code>H</code> and commands that start editing a new file.</p>
  <table>
    <thead>
      <tr class="header">
        <th>List</th>
        <th>List all entries</th>
        <th>Go to older position</th>
        <th>Go to newer position</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>jumplist</td>
        <td><code>:jumps</code></td>
        <td><code>[count]&lt;c-o&gt;</code></td>
        <td><code>[count]&lt;c-i&gt;</code></td>
      </tr>
      <tr class="even">
        <td>changelist</td>
        <td><code>:changes</code></td>
        <td><code>[count]g;</code></td>
        <td><code>[count]g,</code></td>
      </tr>
    </tbody>
  </table>
  <p>When you list all entries, a marker <code>&gt;</code> will be used to show the current position. Usually that will
    be below position 1, the latest position.</p>
  <p>If you want both lists to persist after restarting Vim, you need to use the viminfo file and
    <code>:h viminfo-'</code>.</p>
  <p><strong>NOTE</strong>: The position before the latest jump is also kept as a <a href="#marks">mark</a> and can be
    jumped to via <code>``</code> or <code>''</code>.</p>
  <p>Help:</p>
  <pre><code>:h changelist
:h jumplist</code></pre>
  <h2 id="undo-tree">Undo tree</h2>
  <p>The latest changes to the text state are remembered. You can use <em>undo</em> to revert changes and <em>redo</em>
    to reapply previously reverted changes.</p>
  <p>The important bit to understand it that the data structure holding recent changes is not a <a
      href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">queue</a> but a <a
      href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a>! Your changes are nodes in the tree and each
    (but the top node) has a parent node. Each node keeps information about the changed text and time. A branch is a
    series of nodes that starts from any node and goes up to the top node. New branches get created when you undo a
    change and then insert something else.</p>
  <pre><code>ifoo&lt;esc&gt;
obar&lt;esc&gt;
obaz&lt;esc&gt;
u
oquux&lt;esc&gt;</code></pre>
  <p>Now you have 3 lines and the undo tree looks like this:</p>
  <pre><code>     foo(1)
       /
    bar(2)
   /      \
baz(3)   quux(4)</code></pre>
  <p>The undo tree has 4 changes. The numbers represent the <em>time</em> the nodes were created.</p>
  <p>Now there are two ways to traverse this tree, let’s call them <em>branch-wise</em> and <em>time-wise</em>.</p>
  <p>Undo (<code>u</code>) and redo (<code>&lt;c-r&gt;</code>) work branch-wise. They go up and down the current branch.
    <code>u</code> will revert the text state to the one of node “bar”. Another <code>u</code> will revert the text
    state even further, to the one of node “foo”. Now <code>&lt;c-r&gt;</code> goes back to the state of node “bar” and
    another <code>&lt;c-r&gt;</code> to the state of node “quux”. (There’s no way to reach node “baz” using branch-wise
    commands anymore.)</p>
  <p>Opposed to this, <code>g-</code> and <code>g+</code> work time-wise. Thus, <code>g-</code> won’t revert to the
    state of node “bar”, like <code>u</code> does, but to the chronologically previous state, node “baz”. Another
    <code>g-</code> would revert the state to the one of node “bar” and so on. Thus, <code>g-</code> and <code>g+</code>
    simply go back and forth in time, respectively.</p>
  <table>
    <colgroup>
      <col style="width: 70%" />
      <col style="width: 29%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Command / Mapping</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>[count]u</code>, <code>:undo [count]</code></td>
        <td>Undo [count] changes.</td>
      </tr>
      <tr class="even">
        <td><code>[count]&lt;c-r&gt;</code>, <code>:redo</code></td>
        <td>Redo [count] changes.</td>
      </tr>
      <tr class="odd">
        <td><code>U</code></td>
        <td>Undo all changes to the line of the latest change.</td>
      </tr>
      <tr class="even">
        <td><code>[count]g-</code>, <code>:earlier [count]?</code></td>
        <td>Go to older text state [count] times. The “?” can be either “s”, “m”, “h”, “d”, or “f”. E.g.
          <code>:earlier 2d</code> goes to the text state from 2 days ago. <code>:earlier 1f</code> will go to the state
          of the latest file save.</td>
      </tr>
      <tr class="odd">
        <td><code>[count]g+</code>, <code>:later [count]?</code></td>
        <td>Same as above, but other direction.</td>
      </tr>
    </tbody>
  </table>
  <p>The undo tree is kept in memory and will be lost when Vim quits. See <a href="#undo-files">Undo files</a> for how
    to enable persistent undo.</p>
  <p>If you’re confused by the undo tree, <a href="https://github.com/mbbill/undotree">undotree</a> does a great job at
    visualizing it.</p>
  <p>Help:</p>
  <pre><code>:h undo.txt
:h usr_32</code></pre>
  <h2 id="quickfix-and-location-lists">Quickfix and location lists</h2>
  <p>The quickfix list is a data structure that holds file positions. Essentially, each entry in the quickfix list
    consists of a file path, a line number and optional column, and a description.</p>
  <p>Typical use cases are assembling compiler errors or results of a grep tool.</p>
  <p>Vim has a special type of buffer for showing the quickfix list: the quickfix buffer. Each line in the quickfix
    buffer shows one entry from the quickfix list.</p>
  <p>Usually you open a new window to display the quickfix list: the quickfix window. When that happens, the last window
    gets associated with the quickfix window.</p>
  <p>In the quickfix buffer <code>&lt;cr&gt;</code> opens the selected entry in the associated window and
    <code>&lt;c-w&gt;&lt;cr&gt;</code> in a new window.</p>
  <p>The quickfix list was named after the “quick fix” feature from the <a
      href="https://en.wikipedia.org/wiki/Aztec_C">Aztec C compiler</a>.</p>
  <p>Actually there are two kinds of lists: quickfix and location lists. They behave almost the same, but have the
    follwing differences:</p>
  <ul>
    <li>There is only one quickfix list. There can be multiple location lists; one per window.</li>
    <li>They use slightly different commands for navigation.</li>
  </ul>
  <table>
    <thead>
      <tr class="header">
        <th>Action</th>
        <th>Quickfix</th>
        <th>Location</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>open window</td>
        <td><code>:copen</code></td>
        <td><code>:lopen</code></td>
      </tr>
      <tr class="even">
        <td>close window</td>
        <td><code>:cclose</code></td>
        <td><code>:lclose</code></td>
      </tr>
      <tr class="odd">
        <td>next entry</td>
        <td><code>:cnext</code></td>
        <td><code>:lnext</code></td>
      </tr>
      <tr class="even">
        <td>previous entry</td>
        <td><code>:cprevious</code></td>
        <td><code>:lprevious</code></td>
      </tr>
      <tr class="odd">
        <td>first entry</td>
        <td><code>:cfirst</code></td>
        <td><code>:lfirst</code></td>
      </tr>
      <tr class="even">
        <td>last entry</td>
        <td><code>:clast</code></td>
        <td><code>:llast</code></td>
      </tr>
    </tbody>
  </table>
  <p>Mind that the quickfix and location windows don’t need to be open for these commands to work.</p>
  <p>See <code>:h quickfix</code> for more information and a full list of commands.</p>
  <p>For conciseness, <em>quickfix</em> and <em>location</em> are often abbreviated as <em>qf</em> and <em>loc</em>
    respectively.</p>
  <p><strong>Example</strong>:</p>
  <p>Let us use our good old friend <code>grep</code> for searching the files in the current directory recursively for a
    certain query and put the results in the quickfix list.</p>
  <pre class="vim"><code>:let &amp;grepprg = &#39;grep -Rn $* .&#39;
:grep! foo
&lt;grep output - hit enter&gt;
:copen</code></pre>
  <p>Assuming any files contained the string “foo”, it should be shown now in the quickfix window.</p>
  <h2 id="macros">Macros</h2>
  <p>Vim allows <em>recording</em> typed characters into a <a href="#registers">register</a>. It’s a great way to
    automate certain tasks on the fly. (For more elaborate tasks, Vim scripting should be used instead.)</p>
  <ul>
    <li>Start recording by typing <code>q</code> followed by the register, e.g. <code>q</code>. (The command-line will
      signify this via “recording <span class="citation" data-cites="q">@q</span>”.)</li>
    <li>Stop recording by hitting <code>q</code> once again.</li>
    <li>Execute the macro via <code>[count]@q</code>.</li>
    <li>Repeat the last used macro via <code>[count]@@</code>.</li>
  </ul>
  <p><strong>Example 1:</strong></p>
  <p>Insert a line and repeat it 10 times:</p>
  <pre><code>qq
iabc&lt;cr&gt;&lt;esc&gt;
q
10@q</code></pre>
  <p>(The same could be done without macros: <code>oabc&lt;esc&gt;10.</code>)</p>
  <p><strong>Example 2:</strong></p>
  <p>For adding line numbers in front of all lines, start on the first line and add “1.” to it manually. Increment the
    number under the cursor by using <code>&lt;c-a&gt;</code>, displayed as <code>^A</code>.</p>
  <pre><code>qq
0yf jP0^A
q
1000@q</code></pre>
  <p>Here we simply hope that the file doesn’t contain more than 1000 lines when using <code>1000@q</code>, but we can
    also use a <em>recursive macro</em>, which executes until the macro can’t be applied to a line anymore:</p>
  <pre><code>qq
0yf jP0^A@q
q
@q</code></pre>
  <p>(The same could be done without macros: <code>:%s/^/\=line('.') . '. '</code>)</p>
  <p>Mind that I also show how to achieve the same without using macros, but this mostly works only for such simple
    examples. For more complex automation, macros are the bomb!</p>
  <p>Also see: <a href="#quickly-edit-your-macros">Quickly edit your macros</a></p>
  <p>Help:</p>
  <pre><code>:h recording
:h &#39;lazyredraw&#39;</code></pre>
  <h2 id="colorschemes">Colorschemes</h2>
  <p>Colorschemes are the way to style your Vim. Vim consists of many components and each of those can be customized
    with different colors for the foreground, background and a few other attributes like bold text etc. They can be set
    like this:</p>
  <pre class="vim"><code>:highlight Normal ctermbg=1 guibg=red</code></pre>
  <p>This would paint the background of the editor red. See <code>:h :highlight</code> for more information.</p>
  <p>So, colorschemes are mostly collections of <code>:highlight</code> commands.</p>
  <p>Actually, most colorschemes are really 2 colorschemes! The example above sets colors via <code>ctermbg</code> and
    <code>guibg</code>. The former definition (<code>cterm*</code>) will only be used if Vim was started in a terminal
    emulator, e.g. xterm. The latter (<code>gui*</code>) will be used in graphical environments like gvim or MacVim.</p>
  <p>If you ever happen to use a colorscheme in terminal Vim and the colors don’t look like the ones in the screenshot
    at all, chances are that the colorscheme only defines colors for the GUI. Conversely, if you use a graphical Vim
    (e.g. gvim or MacVim) and the colors look off, the colorscheme might only define colors for the terminal.</p>
  <p>The latter case can be “solved” by enabling true colors in Neovim or Vim 7.4.1830 and newer. This makes terminal
    Vim use the GUI definitions instead, but also requires the terminal emulator itself and all software in between
    (e.g. tmux) to be capable of handling true colors. (<a href="https://gist.github.com/XVilka/8346728">This gist</a>
    gives a good overview about the topic.)</p>
  <p>Help:</p>
  <ul>
    <li><code>:h 'termguicolors'</code></li>
    <li><a href="PLUGINS.md#colorschemes-1">List of colorschemes</a></li>
    <li><a href="#cosmetic-changes-to-colorschemes">Cosmetic changes to colorschemes</a></li>
  </ul>
  <h2 id="folding">Folding</h2>
  <p>Every text (or source code) has a certain structure. If you have a structure, it means you have regions of
    logically separated text. Folding allows to “fold” such a region into a single line and displaying a short
    description. There are many commands that act on these regions called <em>folds</em>. Folds can be nested.</p>
  <p>Vim distinguishes between several types of fold methods:</p>
  <table>
    <thead>
      <tr class="header">
        <th>‘foldmethod’</th>
        <th>Usage</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>diff</td>
        <td>Used in diff windows to fold unchanged text.</td>
      </tr>
      <tr class="even">
        <td>expr</td>
        <td>Uses <code>'foldexpr'</code> to basically create a new fold method.</td>
      </tr>
      <tr class="odd">
        <td>indent</td>
        <td>Folds based on indentation.</td>
      </tr>
      <tr class="even">
        <td>manual</td>
        <td>Create folds yourself via <code>zf</code>, <code>zF</code>, and <code>:fold</code>.</td>
      </tr>
      <tr class="odd">
        <td>marker</td>
        <td>Folds based on markers in the text (often in comments).</td>
      </tr>
      <tr class="even">
        <td>syntax</td>
        <td>Folds based on syntax, e.g. folding <code>if</code> blocks.</td>
      </tr>
    </tbody>
  </table>
  <p><strong>NOTE</strong>: Folding can be computationally intensive! If you experience any performance drawbacks (small
    delays when typing), have a look at <a href="https://github.com/Konfekt/FastFold">FastFold</a>, which prevents Vim
    from updating folds when it’s not needed.</p>
  <p>Help:</p>
  <pre><code>:h usr_28
:h folds</code></pre>
  <h2 id="sessions">Sessions</h2>
  <p>If you save a <strong>view</strong> (<code>:h :mkview</code>), the current state of the window (and options and
    mappings) gets saved for later use (<code>:h :loadview</code>).</p>
  <p>A <strong>session</strong> saves the views of all windows plus global settings. It basically makes a snapshot of
    your current Vim instance and saves it in a session file. Let me stress this: it saves the current state; everything
    done after saving a session won’t be part of the session file. To “update” a session, simply write it out again.</p>
  <p>This makes it perfect for saving your <em>projects</em> and easy to switch between them.</p>
  <p>Try it right now! Open a few windows and tabs and do <code>:mksession Foo.vim</code>. If you omit the filename,
    <code>Session.vim</code> will be assumed. The file will be saved to the current working directory, check
    <code>:pwd</code>. Restart Vim and do <code>:source Foo.vim</code> and voilà, the buffer list, window layout,
    mappings, working directory etc. should all be the same as before you saved the session. Do some more work and
    update the session by overwriting the already existing session file with <code>:mksession! Foo.vim</code>.</p>
  <p>Note that a session file is really just a collection of Vim commands that are supposed to restore a certain state
    of a Vim instance, so feel free to take a look at it: <code>:vs Foo.vim</code>.</p>
  <p>You can tell Vim what things to save in a session by setting <code>'sessionoptions'</code>.</p>
  <p>For scripting purposes Vim keeps the name of the last sourced or written session in the internal variable
    <code>v:this_session</code>.</p>
  <p>Help:</p>
  <pre><code>:h Session
:h &#39;sessionoptions&#39;
:h v:this_session</code></pre>
  <h2 id="locality">Locality</h2>
  <p>Many of the concepts mentioned above also have <em>local</em> counterparts:</p>
  <table>
    <thead>
      <tr class="header">
        <th>Global</th>
        <th>Local</th>
        <th>Scope</th>
        <th>Help</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>:set</code></td>
        <td><code>:setlocal</code></td>
        <td>buffer or window</td>
        <td><code>:h local-options</code></td>
      </tr>
      <tr class="even">
        <td><code>:map</code></td>
        <td><code>:map &lt;buffer&gt;</code></td>
        <td>buffer</td>
        <td><code>:h :map-local</code></td>
      </tr>
      <tr class="odd">
        <td><code>:autocmd</code></td>
        <td><code>:autocmd * &lt;buffer&gt;</code></td>
        <td>buffer</td>
        <td><code>:h autocmd-buflocal</code></td>
      </tr>
      <tr class="even">
        <td><code>:cd</code></td>
        <td><code>:lcd</code></td>
        <td>window</td>
        <td><code>:h :lcd</code></td>
      </tr>
      <tr class="odd">
        <td><code>&lt;leader&gt;</code></td>
        <td><code>&lt;localleader&gt;</code></td>
        <td>buffer</td>
        <td><code>:h maplocalleader</code></td>
      </tr>
    </tbody>
  </table>
  <p><a href="https://vimhelp.appspot.com/usr_41.txt.html#41.2">Variables also have different scopes</a>.</p>
  <h1 id="usage-1">Usage</h1>
  <h2 id="getting-help-offline">Getting help offline</h2>
  <p>Vim comes with great documentation in the form of single text files with a special layout. Vim uses a system based
    on tags for accessing certain parts of those help files.</p>
  <p>First of all, read this: <code>:help :help</code>. This will open the file
    <code>$VIMRUNTIME/doc/helphelp.txt</code> in a new window and jump to the <code>:help</code> tag within that file.
  </p>
  <p>A few simple rules:</p>
  <ul>
    <li>options are enclosed in single quotes, e.g. <code>:h 'textwidth'</code></li>
    <li>VimL functions end in <code>()</code>, e.g. <code>:h reverse()</code></li>
    <li>commands start with <code>:</code>, e.g. <code>:h :echo</code></li>
  </ul>
  <p>You can use <code>&lt;c-d&gt;</code> (this is <kbd>ctrl</kbd>+<kbd>d</kbd>) to list all tags that match the
    currently entered query. E.g. <code>:h tab&lt;c-d&gt;</code> will get you a list of all tags from <code>tab</code>
    over <code>'softtabstop'</code> to <code>setting-guitablabel</code>.</p>
  <p>You want to list all VimL functions? Simple: <code>:h ()&lt;c-d&gt;</code>. You want to list all VimL functions
    that concern windows? <code>:h win*()&lt;c-d&gt;</code>.</p>
  <p>This quickly becomes second nature, but especially in the beginning, you sometimes don’t know any part of the tag
    you are looking for. You can only imagine some keywords that could be involved. <code>:helpgrep</code> to the
    rescue!</p>
  <pre><code>:helpgrep backwards</code></pre>
  <p>This will look for “backwards” in all documentation files and jump to the first match. The matches will be
    assembled in the quickfix list. Use <code>:cn</code>/<code>:cp</code> to jump to the next/previous match. Or use
    <code>:copen</code> to open the quickfix window, navigate to an entry and hit <code>&lt;cr&gt;</code> to jump to
    that match. See <code>:h quickfix</code> for the whole truth.</p>
  <h2 id="getting-help-offline-alternative">Getting help offline (alternative)</h2>
  <p>This list was compiled by <span class="citation" data-cites="chrisbra">@chrisbra</span>, one of the most active Vim
    developers, and posted to <a href="https://groups.google.com/forum/#!forum/vim_dev">vim_dev</a>.</p>
  <p>It’s reposted here with minor changes.</p>
  <hr />
  <p>If you know what you are looking for, it is usually easier to search for it using the help system, because the
    subjects follow a certain style guide.</p>
  <p>Also, the help has the advantage of belonging to your particular Vim version, so that obsolete topics or topics
    that have been added later won’t turn up.</p>
  <p>Therefore, it is essential to learn the help system and the language it uses. Here are some examples (not
    necessarily complete and I might have forgotten something).</p>
  <ol type="1">
    <li>
      <p>Options are enclosed in single quotes. So you would use <code>:h 'list'</code> to go to the help topic for the
        list option. If you only know, you are looking for a certain option, you can also do <code>:h options.txt</code>
        to open the help page which describes all option handling and then you can search using regular expressions
        e.g. <code>/width</code>. Certain options have their own namespace, e.g. <code>:h cpo-a</code>,
        <code>:h cpo-A</code>, <code>:h cpo-b</code>, and so on.</p>
    </li>
    <li>
      <p>Normal mode commands are just that. Use <code>:h gt</code> to go to the help page for the “gt” command.</p>
    </li>
    <li>
      <p>Regexp items always start with “/”, so <code>:h /\+</code> takes you to the help item for the “+” quantifier in
        Vim regexes. If you need to know anything about regular expressions, start reading at
        <code>:h pattern.txt</code>.</p>
    </li>
    <li>
      <p>Key combinations. They usually start with a single letter indicating the mode for which they can be used. E.g.
        <code>:h i_CTRL-X</code> takes you to the family of CTRL-X commands for insert mode which can be used to auto
        complete different things. Note that certain keys will always be written the same, e.g. Control will always be
        CTRL. Note, for normal mode commands, the “n” is left away, e.g. <code>:h CTRL-A</code>. In contrast,
        <code>:h c_CTRL-R</code> will describe what CTRL-R does when entering commands in the command line and
        <code>:h v_Ctrl-A</code> talks about incrementing numbers in visual mode and <code>:h g_CTRL-A</code> talks
        about the g<C-A> command (thus you have to press “g” then <Ctrl-A>). Here the “g” stand for the normal command
            “g” which always expect a second key before doing something similar to the commands starting with “z”.</p>
    </li>
    <li>
      <p>Registers always start with “quote” so use <code>:h quote</code> to find out about the special “:” register.
      </p>
    </li>
    <li>
      <p>Vim script (VimL) is available at <code>:h eval.txt</code>. Certain aspects of the language are available at
        <code>:h expr-X</code> where ‘X’ is a single letter, e.g. <code>:h expr-!</code> will take you to the topic
        describing the ‘!’ (Not) operator for VimL. Also important, see <code>:h function-list</code> to find a short
        description of all functions available.</p>
    </li>
    <li>
      <p>Mappings are talked about in the help page <code>:h map.txt</code>. Use <code>:h mapmode-i</code> to find out
        about the <code>:imap</code> command. Also use <code>:map-topic</code> to find out about certain subtopics
        particular for mappings (e.g. <code>:h :map-local</code> for buffer-local mappings or <code>:h map_bar</code>
        for how the ‘|’ is handled in mappings.</p>
    </li>
    <li>
      <p>Command definitions are talked about at <code>:h command-*</code>, so use :h command-bar to find out about the
        ‘!’ argument for custom commands.</p>
    </li>
    <li>
      <p>Window management commands always start with CTRL-W, so you find the corresponding help at
        <code>:h CTRL-W_*</code> (e.g. <code>:h CTRL-W_p</code> for switch to the previously accessed window). You can
        also access <code>:h windows.txt</code> and read your way through, if you are looking for window handling
        command.</p>
    </li>
    <li>
      <p>Ex commands always start with “:”, so <code>:h :s</code> covers the “:s” command.</p>
    </li>
    <li>
      <p>Use CTRL-D after typing a topic and let Vim try to complete to all available topics.</p>
    </li>
    <li>
      <p>Use <code>:helpgrep</code> to search in all help pages (usually also includes help pages by installed plugins).
        See <code>:h :helpgrep</code> for how to use it. Once you have searched for a topic, all matches are available
        in the quickfix (or location) window which can be opened with <code>:copen</code> or <code>:lopen</code>. There
        you can also use <code>/</code> to further filter the matches.</p>
    </li>
    <li>
      <p><code>:h helphelp</code> contains some information on how to use the help.</p>
    </li>
    <li>
      <p>The user manual. This describes help topics for beginners in a rather friendly way. Start at
        <code>:h usr_toc.txt</code> to find the table of content (as you might have guessed). Skimming over that help to
        find certain topics, .e.g you will find an entry “Digraphs” and “Entering special characters” in chapter 24 (so
        use <code>:h usr_24.txt</code> to go to that particular help page).</p>
    </li>
    <li>
      <p>Highlighting groups always start with <code>hl-*</code>. E.g. <code>:h hl-WarningMsg</code> talks about the
        “WarningMsg” highlighting group.</p>
    </li>
    <li>
      <p>Syntax highlighting is namespaced to “:syn-topic”, e.g. <code>:h :syn-conceal</code> talks about the conceal
        argument for the :syn command.</p>
    </li>
    <li>
      <p>Quickfix commands usually start with “:c”, while location list commands usually start with “:l”.</p>
    </li>
    <li>
      <p><code>:h BufWinLeave</code> talks about the BufWinLeave autocmd. Also, <code>:h autocommands-events</code>
        talks about all possible events.</p>
    </li>
    <li>
      <p>Startup arguments always start with “-”, so <code>:h -f</code> takes you to the help of the “-f” command switch
        of Vim.</p>
    </li>
    <li>
      <p>Compiled extra features always start with “+”, so <code>:h +conceal</code> talks about the conceal support.</p>
    </li>
    <li>
      <p>Error codes can be looked up directly in the help. <code>:h E297</code> takes you exactly to the description of
        the error message. Sometimes however, those error codes are not described, but rather are listed at the Vim
        command that usually causes this. E.g. <code>:h hE128</code> takes you directly to the <code>:function</code>
        command.</p>
    </li>
    <li>
      <p>Documentation for included syntax files is usually available at <code>:h ft-*-syntax</code>. E.g.
        <code>:h ft-c-syntax</code> talks about the C syntax file and the options it provides. Sometimes, additional
        sections for omni completion (<code>:h ft-php-omni</code>) or filetype plugins (<code>:h ft-tex-plugin</code>)
        are available.</p>
    </li>
  </ol>
  <p>Also, a link to the user documentation (which describes certain commands more from a user perspective and less
    detailed) will be mentioned at the top of help pages if they are available. So <code>:h pattern.txt</code> mentions
    the user guide topics <code>:h 03.9</code> and <code>:h usr_27</code>.</p>
  <h2 id="getting-help-online">Getting help online</h2>
  <p>If you have an issue you can’t resolve or are in need of general guidance, see the <a
      href="https://groups.google.com/forum/#!forum/vim_use">vim_use</a> mailing list. Another great resource is using
    <a href="https://de.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a>. The channel <code>#vim</code> on <a
      href="https://freenode.net">Freenode</a> is huge and usually full of helpful people.</p>
  <p>If you want to report a Vim bug, use the <a href="https://groups.google.com/forum/#!forum/vim_dev">vim_dev</a>
    mailing list.</p>
  <h2 id="autocmds-in-practice">Autocmds in practice</h2>
  <p>You can trigger any event right now: <code>:doautocmd BufRead</code>.</p>
  <h3 id="user-events">User events</h3>
  <p>Especially for plugins it’s useful to create your own “User” events:</p>
  <pre class="vim"><code>function! Chibby()
  &quot; A lot of stuff is happening here.
  &quot; And at last..
  doautocmd User ChibbyExit
endfunction</code></pre>
  <p>Now users of your plugin can execute anything when Chibby finishes running:</p>
  <pre class="vim"><code>autocmd User ChibbyExit call ChibbyCleanup()</code></pre>
  <p>By the way, if there’s no “catching” :autocmd, :doautocmd will output a pesky “No matching autocommands” message.
    That’s why many plugins use <code>silent doautocmd ...</code> instead. But this has the disadvantage, that you can’t
    simply use <code>echo "foo"</code> in the :autocmd, you have to use <code>unsilent echo "foo"</code> instead..</p>
  <p>That’s why it’s better to check if there even is a receiving autocmd and not bothering emitting the event
    otherwise:</p>
  <pre class="vim"><code>if exists(&#39;#User#ChibbyExit&#39;)
  doautocmd User ChibbyExit
endif</code></pre>
  <p>Help: <code>:h User</code></p>
  <h3 id="nested-autocmds">Nested autocmds</h3>
  <p>By default, autocmds do not nest! If an autocmd executes a command, which in turn would usually trigger another
    event, it won’t happen.</p>
  <p>Let’s say every time you start Vim, you want to automatically open your vimrc:</p>
  <pre class="vim"><code>autocmd VimEnter * edit $MYVIMRC</code></pre>
  <p>When you now start Vim, it will open your vimrc, but the first thing you’ll notice is that there won’t be any
    highlighting although usually there would be.</p>
  <p>The problem is that <code>:edit</code> in your non-nested autocmd won’t trigger the “BufRead” event, so the
    filetype never gets set to “vim” and <code>$VIMRUNTIME/syntax/vim.vim</code> never sourced. See
    <code>:au BufRead *.vim</code>. Use this instead:</p>
  <pre class="vim"><code>autocmd VimEnter * nested edit $MYVIMRC</code></pre>
  <p>Help: <code>:h autocmd-nested</code></p>
  <h2 id="clipboard">Clipboard</h2>
  <p>Required <a href="#what-kind-of-vim-am-i-running">features</a>: <code>+clipboard</code> and optionally
    <code>+xterm_clipboard</code> if you want to use the <code>'clipboard'</code> option on a Unix system with a Vim
    that doesn’t have GUI support.</p>
  <p>Help:</p>
  <pre><code>:h &#39;clipboard&#39;
:h gui-clipboard
:h gui-selections</code></pre>
  <p>Also see: <a href="#bracketed-paste-or-why-do-i-have-to-set-paste-all-the-time">Bracketed paste (or why do I have
      to set ‘paste’ all the time?)</a></p>
  <h3 id="clipboard-usage-windows-macos">Clipboard usage (Windows, macOS)</h3>
  <p>Windows comes with a <a
      href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms649012(v=vs.85).aspx">clipboard</a> and macOS
    comes with a <a
      href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008100-SW1">pasteboard</a>.
  </p>
  <p>Both work like most users would expect them to work. You copy selected text with
    <code>ctrl+c</code>/<code>cmd+c</code> and paste them in another application with
    <code>ctrl+v</code>/<code>cmd+v</code>.</p>
  <p>Note that copied text is actually transferred to the clipboard, so you can close the application you copied from
    before pasting in another application without problems.</p>
  <p>Whenever this happens, the clipboard register <code>*</code> gets filled with the selection. From Vim use
    <code>"*y</code> and <code>"*p</code> to yank and paste from the clipboard respectively.</p>
  <p>If you don’t even want to specify the <code>*</code> register all the time, put this in your vimrc:</p>
  <pre class="vim"><code>set clipboard=unnamed</code></pre>
  <p>Usually all yank/delete/put operations fill the <code>"</code> register, now the <code>*</code> register is used
    for the same operations, therefore simply <code>y</code> and <code>p</code> will be enough.</p>
  <p>Let me repeat: Using the option above means that every yank/paste, even when only used in the same Vim window, will
    alter the clipboard. Decide for yourself if this is useful or not.</p>
  <p>If you’re even too lazy to type <code>y</code>, you can send every visual selection to the clipboard by using these
    settings:</p>
  <pre class="vim"><code>set clipboard=unnamed,autoselect
set guioptions+=a</code></pre>
  <p>Help:</p>
  <pre><code>:h clipboard-unnamed
:h autoselect
:h &#39;go_a&#39;</code></pre>
  <h3 id="clipboard-usage-linux-bsd">Clipboard usage (Linux, BSD, …)</h3>
  <p>If your OS uses <a href="http://www.x.org/wiki">X</a>, things work a bit different. X implements the <a
      href="http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html">X Window System Protocol</a> which happens to
    be at major version 11 since 1987, hence X is also often called X11.</p>
  <p>Prior, in X10, <a
      href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Cut_Buffers">cut
      buffers</a> were introduced that kind of worked like a <em>clipboard</em> as in copied text was actually held by X
    and it was accessible by all other applications. This mechanism still exists in X, but its use is deprecated now and
    most software doesn’t use it anymore.</p>
  <p>Nowadays data is transferred between applications by the means of <a
      href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Selections">selections</a>.
    From the 3 <em>selection atoms</em> defined, only 2 are used in practice: PRIMARY and CLIPBOARD.</p>
  <p>Selections work roughly like this:</p>
  <pre><code>Program A: &lt;ctrl+c&gt;
Program A: assert ownership of CLIPBOARD
Program B: &lt;ctrl+v&gt;
Program B: note that ownership of CLIPBOARD is hold by Program A
Program B: request data from Program A
Program A: respond to request and send data to Program B
Program B: receives data from Program A and inserts it into the window</code></pre>
  <table>
    <thead>
      <tr class="header">
        <th>Selection</th>
        <th>When used?</th>
        <th>How to paste?</th>
        <th>How to access from Vim?</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>PRIMARY</td>
        <td>Selecting text</td>
        <td><code>middle-click</code>, <code>shift+insert</code></td>
        <td><code>*</code> register</td>
      </tr>
      <tr class="even">
        <td>CLIPBOARD</td>
        <td>Selecting text and <code>ctrl+c</code></td>
        <td><code>ctrl+v</code></td>
        <td><code>+</code> register</td>
      </tr>
    </tbody>
  </table>
  <p><strong>NOTE</strong>: Selections (no, not even the CLIPBOARD selection) are never kept in the X server! Thus, you
    lose the data copied with <code>ctrl+c</code> when the application closes.</p>
  <p>Use <code>"*p</code> to paste the PRIMARY selection or <code>"+y1G</code> to yank the entire file to the CLIPBOARD
    selection.</p>
  <p>If you happen to access one of the two registers all the time, consider using:</p>
  <pre class="vim"><code>set clipboard^=unnamed      &quot; * register
&quot; or
set clipboard^=unnamedplus  &quot; + register</code></pre>
  <p>(The <code>^=</code> is used to prepend to the default value, <code>:h :set^=</code>.)</p>
  <p>This will make all yank/delete/put operations use either <code>*</code> or <code>+</code> instead of the unnamed
    register <code>"</code>. Afterwards you can simply use <code>y</code> or <code>p</code> for accessing your chosen X
    selection.</p>
  <p>Help:</p>
  <pre class="vim"><code>:h clipboard-unnamed
:h clipboard-unnamedplus</code></pre>
  <h2 id="restore-cursor-position-when-opening-file">Restore cursor position when opening file</h2>
  <p>When you open a file, the cursor will be positioned at line 1, column 1. Fortunately the viminfo file remembers <a
      href="#marks">marks</a>. The <code>"</code> mark contains the position in the buffer where you left off.</p>
  <pre class="vim"><code>autocmd BufReadPost *
    \ if line(&quot;&#39;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;= line(&quot;$&quot;) |
    \   execute &quot;normal! g`\&quot;&quot; |
    \ endif</code></pre>
  <p>Read: If the mark <code>"</code> contains a line number greater than line 1 but not greater than the last line in
    the file, jump to it.</p>
  <pre><code>:h viminfo-&#39;
:h `quote
:h g`</code></pre>
  <h2 id="temporary-files">Temporary files</h2>
  <h3 id="backup-files">Backup files</h3>
  <p>Before saving a file, Vim creates a backup file. If writing to disk was successful, the backup file will be
    deleted.</p>
  <p>With <code>:set backup</code>, the backup will persist. This means, the backup file will always have the same
    content as the original file <em>before</em> the most recent save. It’s up to you to decide whether this is useful
    or not.</p>
  <p>You can disable backups entirely with <code>:set nobackup nowritebackup</code>, but you shouldn’t need to nowadays.
    <code>'writebackup'</code> is a security feature that makes sure that you don’t lose the original file in case
    saving it should ever fail, no matter whether you keep the backup file afterwards or not.</p>
  <p>If you frequently use Vim to edit huge files, <a href="#editing-huge-files-is-slow">and you probably shouldn’t</a>,
    you can exclude those from backups with <code>'backupskip'</code>.</p>
  <p>Vim knows different ways to create a backup: <em>copying</em> and <em>renaming</em>.</p>
  <ul>
    <li><strong>Copying</strong>
      <ol type="1">
        <li>A full copy of the original file is created and used as backup.</li>
        <li>The original file gets emptied and then filled with the content of the Vim buffer.</li>
      </ol>
    </li>
    <li><strong>Renaming</strong>
      <ol type="1">
        <li>The original file is renamed to the backup file.</li>
        <li>The content of the Vim buffer gets written to a new file with the name of the original file.</li>
      </ol>
    </li>
  </ul>
  <p>See <code>:h 'backupcopy'</code> for all the nitty-gritty details.</p>
  <hr />
  <p>Demo:</p>
  <pre class="vim"><code>:set backup backupskip= backupdir=. backupext=-backup
:e /tmp/foo
ifoo&lt;esc&gt;
:w
&quot; original file gets created, no need for backup file
obar&lt;esc&gt;
:w
&quot; backup file is created, original file gets updated</code></pre>
  <div class="sourceCode" id="cb47">
    <pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb47-1" title="1">$ diff -u /tmp/foo-backup /tmp/foo</a>
<a class="sourceLine" id="cb47-2" title="2"><span class="kw">--- /tmp/foo-backup     2017-04-22 15:05:13.000000000 +0200</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="dt">+++ /tmp/foo    2017-04-22 15:05:25.000000000 +0200</span></a>
<a class="sourceLine" id="cb47-4" title="4"><span class="dt">@@ -1 +1,2 @@</span></a>
<a class="sourceLine" id="cb47-5" title="5"> foo</a>
<a class="sourceLine" id="cb47-6" title="6"><span class="va">+bar</span></a></code></pre>
  </div>
  <hr />
  <pre><code>:h backup
:h write-fail</code></pre>
  <h3 id="swap-files">Swap files</h3>
  <p>When editing a file, unsaved changes get written to a swap file.</p>
  <p>Get the name of the current swap file with <code>:swapname</code>. Disable them with <code>:set noswapfile</code>.
  </p>
  <p>A swap file gets updated either all 200 characters or when nothing was typed for 4 seconds. They get deleted when
    you stop editing the file. You can change these numbers with <code>:h 'updatecount'</code> and
    <code>:h 'updatetime'</code>.</p>
  <p>If Vim gets killed (e.g. power outage), you lose all changes since the last time the file was written to disk, but
    the swap file won’t be deleted. Now, if you edit the file again, Vim will offer the chance to recover the file from
    the swap file.</p>
  <p>When two people try to edit the same file, the second person will get a notice that the swap file already exists.
    It prevents people from trying to save different versions of a file. If you don’t want that behaviour, see
    <code>:h 'directory'</code>.</p>
  <pre><code>:h swap-file
:h usr_11</code></pre>
  <h3 id="undo-files">Undo files</h3>
  <p>The <a href="#undo-tree">undo tree</a> is kept in memory and will be lost when Vim quits. If you want it to
    persist, <code>:set undofile</code>. This will save the undo file for <code>~/foo.c</code> in
    <code>~/foo.c.un~</code>.</p>
  <pre><code>:h &#39;undofile&#39;
:h undo-persistence</code></pre>
  <h3 id="viminfo-files">Viminfo files</h3>
  <p>When backup, swap, and undo files are all about text state, viminfo files are used for saving everything else that
    would otherwise be lost when quitting Vim. The viminfo file keeps histories (command line, search, input),
    registers, marks, buffer list, global variables etc.</p>
  <p>By default, the viminfo is written to <code>~/.viminfo</code>.</p>
  <pre><code>:h viminfo
:h &#39;viminfo&#39;</code></pre>
  <h3 id="example-configuration-for-temporary-files">Example configuration for temporary files</h3>
  <p>Put all temporary files in their own directory under <code>~/.vim/files</code>:</p>
  <pre class="vim"><code>&quot; create directory if needed
if !isdirectory($HOME.&#39;/.vim/files&#39;) &amp;&amp; exists(&#39;*mkdir&#39;)
  call mkdir($HOME.&#39;/.vim/files&#39;)
endif

&quot; backup files
set backup
set backupdir   =$HOME/.vim/files/backup/
set backupext   =-vimbackup
set backupskip  =
&quot; swap files
set directory   =$HOME/.vim/files/swap//
set updatecount =100
&quot; undo files
set undofile
set undodir     =$HOME/.vim/files/undo/
&quot; viminfo files
set viminfo     =&#39;100,n$HOME/.vim/files/info/viminfo</code></pre>
  <h2 id="editing-remote-files">Editing remote files</h2>
  <p>Vim comes with the netrw plugin that enables editing remote files. Actually it transfers the remote file to a local
    temporary file via scp, opens a buffer using that file, and writes the changes back to the remote file on saving.
  </p>
  <p>This is extremely useful if you want to use your local configuration opposed to ssh’ing into a server and use
    whatever the admins want you to use.</p>
  <pre><code>:e scp://bram@awesome.site.com/.vimrc</code></pre>
  <p>If you have a <code>~/.ssh/config</code> set up already, this gets used automatically:</p>
  <pre><code>Host awesome
    HostName awesome.site.com
    Port 1234
    User bram</code></pre>
  <p>Assuming the above content in <code>~/.ssh/config</code>, this works just as well:</p>
  <pre><code>:e scp://awesome/.vimrc</code></pre>
  <p>Similar can be done with a <code>~/.netrc</code>, see <code>:h netrw-netrc</code>.</p>
  <p>Make sure to read <code>:h netrw-ssh-hack</code> and <code>:h g:netrw_ssh_cmd</code>.</p>
  <hr />
  <p>Another possibility is using <a href="https://wiki.archlinux.org/index.php/Sshfs">sshfs</a> which uses <a
      href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a> to mount a remote filesystem into your local
    filesystem.</p>
  <h2 id="managing-plugins">Managing plugins</h2>
  <p><a href="https://github.com/tpope/vim-pathogen">Pathogen</a> was the first popular tool for managing plugins.
    Actually it just adjusts the <em>runtimepath</em> (<code>:h 'rtp'</code>) to include all the things put under a
    certain directory. You have to clone the repositories of the plugins there yourself.</p>
  <p>Real plugin managers expose commands that help you to install and update plugins from within Vim.</p>
  <p><a href="PLUGINS.md#plugin-managers">List of plugin managers</a></p>
  <h2 id="block-insert">Block insert</h2>
  <p>This is a technique to insert the same text on multiple consecutive lines at the same time. See this <a
      href="https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-block_insert.gif">demo</a>.
  </p>
  <p>Switch to visual block mode with <code>&lt;c-v&gt;</code>. Afterwards go down for a few lines. Hit <code>I</code>
    or <code>A</code> and start entering your text.</p>
  <p>It might be a bit confusing at first, but text is always entered for the current line and only after finishing the
    current insertion, the same text will be applied to all other lines of the prior visual selection.</p>
  <p>So a simple example is <code>&lt;c-v&gt;3jItext&lt;esc&gt;</code>.</p>
  <p>If you have lines of different length and want to append the same text right after the end of each line, do this:
    <code>&lt;c-v&gt;3j$Atext&lt;esc&gt;</code>.</p>
  <p>Sometime you need to place the cursor somewhere after the end of the current line. You can’t do that by default,
    but you can set the <code>virtualedit</code> option:</p>
  <pre class="vim"><code>set virtualedit=all</code></pre>
  <p>Afterwards <code>$10l</code> or <code>90|</code> work even after the end of the line.</p>
  <p>See <code>:h blockwise-examples</code> for more info. It might seem complicated at first, but quickly becomes
    second nature.</p>
  <p>If you want to get real fancy, have a look at <a
      href="https://github.com/terryma/vim-multiple-cursors">multiple-cursors</a>.</p>
  <h2 id="running-external-programs-and-using-filters">Running external programs and using filters</h2>
  <p>Disclaimer: Vim is single-threaded, so running an external program in the foreground will block everything else.
    Sure, you can use one of Vim’s programming interfaces, e.g. Lua, and use its thread support, but during that time
    the Vim process is blocked nevertheless. Neovim fixed that by adding a proper job API.</p>
  <p>(Apparently Bram is thinking about adding job control to Vim as well. If you have a very recent version, see
    <code>:helpgrep startjob</code>.)</p>
  <p>Use <code>:!</code> to start a job. If you want to list the files in the current working directory, use
    <code>:!ls</code>. Use <code>|</code> for piping in the shell as usual, e.g. <code>:!ls -1 | sort | tail -n5</code>.
  </p>
  <p>Without a range, the output of <code>:!</code> will be shown in a scrollable window. On the other hand, if a range
    is given, these lines will be <a href="https://en.wikipedia.org/wiki/Filter_(software)">filtered</a>. This means
    they will be piped to the <a
      href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29">stdin</a> of the filter program
    and after processing be replaced by the <a
      href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29">stdout</a> of the filter. E.g.
    for prepending numbers to the next 5 lines, use this:</p>
  <pre><code>:.,+4!nl -ba -w1 -s&#39; &#39;</code></pre>
  <p>Since manually adding the range is quite burdensome, Vim also provides some helpers for convenience. As always with
    ranges, you can also select lines in visual mode and then hit <code>:</code>. There’s also an operator
    <code>!</code> that takes a motion. E.g. <code>!ip!sort</code> will sort the lines of the current paragraph.</p>
  <p>A good use case for filtering is the <a href="https://golang.org">Go programming language</a>. The indentation is
    pretty opinionated, it even comes with a filter called <code>gofmt</code> for indenting Go source code properly. So
    plugins for Go often provide helper commands called <code>:Fmt</code> that basically do <code>:%!gofmt</code>, so
    they indent all lines in the file.</p>
  <p>People often use <code>:r !prog</code> to put the output of prog below the current line, which is fine for scripts,
    but when doing it on the fly, I find it easier to use <code>!!ls</code> instead, which replaces the current line.
  </p>
  <pre><code>:h filter
:h :read!</code></pre>
  <h2 id="cscope">Cscope</h2>
  <p><a href="http://cscope.sourceforge.net/">Cscope</a> does more things than <a
      href="http://ctags.sourceforge.net/">ctags</a>, but only supports C (and C++ and Java to some extent).</p>
  <p>Whereas a tags file only knows where a symbol was defined, a cscope database knows much more about your data:</p>
  <ul>
    <li>Where is this symbol defined?</li>
    <li>Where is this symbol used?</li>
    <li>What is this global symbol’s definition?</li>
    <li>Where did this variable get its value?</li>
    <li>Where is this function in the source files?</li>
    <li>What functions call this function?</li>
    <li>What functions are called by this function?</li>
    <li>Where does the message “out of space” come from?</li>
    <li>Where is this source file in the directory structure?</li>
    <li>What files include this header file?</li>
  </ul>
  <h3 id="build-the-database">1. Build the database</h3>
  <p>Do this in the root of your project:</p>
  <div class="sourceCode" id="cb59">
    <pre
      class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb59-1" title="1">$ <span class="ex">cscope</span> -bqR</a></code></pre>
  </div>
  <p>This will create 3 files: <code>cscope{,.in,.po}.out</code> in the current working directory. Think of them as your
    database.</p>
  <p>Unfortunately <code>cscope</code> only analyzes <code>*.[c|h|y|l]</code> files by default. If you want to use
    cscope for a Java project instead, do this:</p>
  <div class="sourceCode" id="cb60">
    <pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb60-1" title="1">$ <span class="fu">find</span> . -name <span class="st">&quot;*.java&quot;</span> <span class="op">&gt;</span> cscope.files</a>
<a class="sourceLine" id="cb60-2" title="2">$ <span class="ex">cscope</span> -bq</a></code></pre>
  </div>
  <h3 id="add-the-database">2. Add the database</h3>
  <p>Open a connection to your freshly built database:</p>
  <pre class="vim"><code>:cs add cscope.out</code></pre>
  <p>Verify that the connection was made:</p>
  <pre class="vim"><code>:cs show</code></pre>
  <p>(Yes, you can add multiple connections.)</p>
  <h3 id="query-the-database">3. Query the database</h3>
  <pre class="vim"><code>:cs find &lt;kind&gt; &lt;query&gt;</code></pre>
  <p>E.g. <code>:cs find d foo</code> will list all functions that are called by <code>foo(...)</code>.</p>
  <table>
    <thead>
      <tr class="header">
        <th>Kind</th>
        <th>Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>s</td>
        <td><strong>s</strong>ymbol: find all references to the token</td>
      </tr>
      <tr class="even">
        <td>g</td>
        <td><strong>g</strong>lobal: find global definition(s) of the token</td>
      </tr>
      <tr class="odd">
        <td>c</td>
        <td><strong>c</strong>alls: find all calls to the function</td>
      </tr>
      <tr class="even">
        <td>t</td>
        <td><strong>t</strong>ext: find all instances of the text</td>
      </tr>
      <tr class="odd">
        <td>e</td>
        <td><strong>e</strong>grep: egrep search for the word</td>
      </tr>
      <tr class="even">
        <td>f</td>
        <td><strong>f</strong>ile: open the filename</td>
      </tr>
      <tr class="odd">
        <td>i</td>
        <td><strong>i</strong>ncludes: find files that include the filename</td>
      </tr>
      <tr class="even">
        <td>d</td>
        <td><strong>d</strong>epends: find functions called by this function</td>
      </tr>
    </tbody>
  </table>
  <p>I suggest some convenience mappings e.g.:</p>
  <pre
    class="vim"><code>nnoremap &lt;buffer&gt; &lt;leader&gt;cs :cscope find s  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;cg :cscope find g  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;cc :cscope find c  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;ct :cscope find t  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;ce :cscope find e  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;cf :cscope find f  &lt;c-r&gt;=expand(&#39;&lt;cfile&gt;&#39;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;ci :cscope find i ^&lt;c-r&gt;=expand(&#39;&lt;cfile&gt;&#39;)&lt;cr&gt;$&lt;cr&gt;
nnoremap &lt;buffer&gt; &lt;leader&gt;cd :cscope find d  &lt;c-r&gt;=expand(&#39;&lt;cword&gt;&#39;)&lt;cr&gt;&lt;cr&gt;</code></pre>
  <p>So, when <code>:tag</code> (or <code>&lt;c-]&gt;</code>) jumps to a definition from the tags file,
    <code>:cstag</code> does the same, but also takes connected cscope databases into account. The option
    <code>'cscopetag'</code> makes <code>:tag</code> act like <code>:cstag</code> automatically. This is very convenient
    if you already have tag-related mappings.</p>
  <p>Help: <code>:h cscope</code></p>
  <h2 id="matchit">MatchIt</h2>
  <p>Since Vim is written in C, a lot of features assume C-like syntax. By default, if your cursor is on <code>{</code>
    or <code>#endif</code>, you can use <code>%</code> to jump to the corresponding <code>}</code> or
    <code>#ifdef</code> respectively.</p>
  <p>Vim comes bundled with a plugin called matchit.vim which is not enabled by default. It makes <code>%</code> also
    cycle through HTML tags, if/else/endif constructs in VimL etc. and introduces a few new commands.</p>
  <h4 id="installation-for-vim-8">Installation for Vim 8</h4>
  <pre class="vim"><code>&quot; vimrc
packadd! matchit</code></pre>
  <h4 id="installation-for-vim-7-and-older">Installation for Vim 7 and older</h4>
  <pre class="vim"><code>&quot; vimrc
runtime macros/matchit.vim</code></pre>
  <p>Since the documentation of matchit is pretty extensive, I suggest also doing the following once:</p>
  <pre class="vim"><code>:!mkdir -p ~/.vim/doc
:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
:helptags ~/.vim/doc</code></pre>
  <h4 id="small-intro">Small intro</h4>
  <p>The plugin is ready to use now. See <code>:h matchit-intro</code> for the supported commands and
    <code>:h matchit-languages</code> for the supported languages.</p>
  <p>That said, it’s easy to define your own matching pairs:</p>
  <pre
    class="vim"><code>autocmd FileType python let b:match_words = &#39;\&lt;if\&gt;:\&lt;elif\&gt;:\&lt;else\&gt;&#39;</code></pre>
  <p>Afterwards you can cycle through these 3 statements in any Python file by using <code>%</code> (forward) or
    <code>g%</code> (backward).</p>
  <p>Help:</p>
  <pre><code>:h matchit-install
:h matchit
:h b:match_words</code></pre>
  <h2 id="true-colors">True colors</h2>
  <p>Using true colors in a terminal emulator means being able to use 24 bits for RGB colors. That makes 16777216 (2^24)
    colors instead of the usual 256.</p>
  <p>As explained <a href="#colorschemes">here</a>, colorschemes can actually be <em>two</em> colorschemes by having
    definitions for terminals (xterm) and for GUIs (gvim). This made sense before terminal emulators learned about true
    colors.</p>
  <p>After <code>:set termguicolors</code>, Vim starts emitting escape sequences only understood by a terminal emulator
    that supports true colors. When your colors look weird, chances are your terminal emulator doesn’t support true
    colors or your colorcheme has no GUI colors defined.</p>
  <p>Many people use the terminal multiplexer <a href="https://github.com/tmux/tmux/wiki">tmux</a> which basically sits
    in between the terminal emulator and Vim. To make tmux <em>forward</em> the true color escape sequences emitted by
    Vim, you have to put the following in the user’s <code>.tmux.conf</code>:</p>
  <pre><code>set-option -g  default-terminal &#39;tmux-256color&#39;
set-option -ga terminal-overrides &#39;,xterm-256color:Tc&#39;</code></pre>
  <ul>
    <li>The first line should be the same for most people and denotes the <code>$TERM</code> to be used <em>within</em>
      tmux.</li>
    <li>The second line adds the tmux-specific <code>Tc</code> (true color) capability to the other terminfo entries of
      <code>xterm-256color</code>. Obviously this assumes that the user is using <code>TERM=xterm-256color</code>
      <em>outside</em> of tmux.</li>
  </ul>
  <p>So, here is the checklist for enabling true colors:</p>
  <ul>
    <li>Read <code>:h 'termguicolors'</code>.</li>
    <li>Put <code>set termguicolors</code> in your vimrc.</li>
    <li>Make sure your colorscheme has color definitions for GUIs. (It should contain lines with <code>guifg</code> and
      <code>guibg</code>.)</li>
    <li>Make sure your terminal emulator of choice supports true colors.</li>
    <li>Using tmux? Configure it to add the <code>Tc</code> capability.</li>
  </ul>
  <p>A popular reference for colors in the terminal: https://gist.github.com/XVilka/8346728</p>
  <h1 id="tips-1">Tips</h1>
  <h2 id="go-to-other-end-of-selected-text">Go to other end of selected text</h2>
  <p><code>o</code> and <code>O</code> in a visual selection make the cursor go to the other end. Try with blockwise
    selection to see the difference. This is useful for quickly changing the size of the selected text.</p>
  <pre><code>:h v_o
:h v_O</code></pre>
  <h2 id="saner-behavior-of-n-and-n">Saner behavior of n and N</h2>
  <p>The direction of <code>n</code> and <code>N</code> depends on whether <code>/</code> or <code>?</code> was used for
    searching forward or backward respectively. This is pretty confusing to me.</p>
  <p>If you want <code>n</code> to always search forward and <code>N</code> backward, use this:</p>
  <pre class="vim"><code>nnoremap &lt;expr&gt; n  &#39;Nn&#39;[v:searchforward]
xnoremap &lt;expr&gt; n  &#39;Nn&#39;[v:searchforward]
onoremap &lt;expr&gt; n  &#39;Nn&#39;[v:searchforward]

nnoremap &lt;expr&gt; N  &#39;nN&#39;[v:searchforward]
xnoremap &lt;expr&gt; N  &#39;nN&#39;[v:searchforward]
onoremap &lt;expr&gt; N  &#39;nN&#39;[v:searchforward]</code></pre>
  <h2 id="saner-command-line-history">Saner command-line history</h2>
  <p>If you’re anything like me, you’re used to going to next and previous items via <code>&lt;c-n&gt;</code> and
    <code>&lt;c-p&gt;</code> respectively. By default, this also works in the command-line and recalls older or more
    recent command-lines from history.</p>
  <p>So far, so good. But <code>&lt;up&gt;</code> and <code>&lt;down&gt;</code> are even smarter! They recall the
    command-line whose beginning matches the current command-line. E.g. <code>:echo &lt;up&gt;</code> may change to
    <code>:echo "Vim rocks!"</code>.</p>
  <p>Of course, I don’t want you to reach for the arrow keys:</p>
  <pre class="vim"><code>cnoremap &lt;expr&gt; &lt;c-n&gt; wildmenumode() ? &quot;\&lt;c-n&gt;&quot; : &quot;\&lt;down&gt;&quot;
cnoremap &lt;expr&gt; &lt;c-p&gt; wildmenumode() ? &quot;\&lt;c-p&gt;&quot; : &quot;\&lt;up&gt;&quot;</code></pre>
  <p>Here we also distinguish between command-line history and the wildmenu. See <code>:h 'wildmenu'</code>.</p>
  <p>I depend on this behaviour several times a day.</p>
  <h2 id="saner-ctrl-l">Saner CTRL-L</h2>
  <p>By default, <code>&lt;c-l&gt;</code> clears and redraws the screen (like <code>:redraw!</code>). The following
    mapping does the same, plus de-highlighting the matches found via <code>/</code>, <code>?</code> etc., plus fixing
    syntax highlighting (sometimes Vim loses highlighting due to complex highlighting rules), plus force updating the
    syntax highlighting in diff mode:</p>
  <pre
    class="vim"><code>nnoremap &lt;leader&gt;l :nohlsearch&lt;cr&gt;:diffupdate&lt;cr&gt;:syntax sync fromstart&lt;cr&gt;&lt;c-l&gt;</code></pre>
  <h2 id="disable-audible-and-visual-bells">Disable audible and visual bells</h2>
  <pre class="vim"><code>set noerrorbells
set novisualbell
set t_vb=</code></pre>
  <p>See <a href="http://vim.wikia.com/wiki/Disable_beeping">Vim Wiki: Disable beeping</a>.</p>
  <h2 id="quickly-move-current-line">Quickly move current line</h2>
  <p>Sometimes I need a quick way to move the current line above or below:</p>
  <pre class="vim"><code>nnoremap [e  :&lt;c-u&gt;execute &#39;move -1-&#39;. v:count1&lt;cr&gt;
nnoremap ]e  :&lt;c-u&gt;execute &#39;move +&#39;. v:count1&lt;cr&gt;</code></pre>
  <p>These mappings also take a count, so <code>2]e</code> moves the current line 2 lines below.</p>
  <h2 id="quickly-add-empty-lines">Quickly add empty lines</h2>
  <pre class="vim"><code>nnoremap [&lt;space&gt;  :&lt;c-u&gt;put! =repeat(nr2char(10), v:count1)&lt;cr&gt;&#39;[
nnoremap ]&lt;space&gt;  :&lt;c-u&gt;put =repeat(nr2char(10), v:count1)&lt;cr&gt;</code></pre>
  <p>Now <code>5[&lt;space&gt;</code> inserts 5 blank lines above the current line.</p>
  <h2 id="quickly-edit-your-macros">Quickly edit your macros</h2>
  <p>This is a real gem! The mapping takes a register (or <code>*</code> by default) and opens it in the cmdline-window.
    Hit <code>&lt;cr&gt;</code> when you’re done editing for setting the register.</p>
  <p>I often use this to correct typos I did while recording a macro.</p>
  <pre
    class="vim"><code>nnoremap &lt;leader&gt;m  :&lt;c-u&gt;&lt;c-r&gt;&lt;c-r&gt;=&#39;let @&#39;. v:register .&#39; = &#39;. string(getreg(v:register))&lt;cr&gt;&lt;c-f&gt;&lt;left&gt;</code></pre>
  <p>Use it like this <code>&lt;leader&gt;m</code> or <code>"q&lt;leader&gt;m</code>.</p>
  <p>Notice the use of <code>&lt;c-r&gt;&lt;c-r&gt;</code> to make sure that the <code>&lt;c-r&gt;</code> is inserted
    literally. See <code>:h c_^R^R</code>.</p>
  <h2 id="quickly-jump-to-header-or-source-file">Quickly jump to header or source file</h2>
  <p>This technique can probably be applied to many filetypes. It sets <em>file marks</em> (see <code>:h marks</code>)
    when leaving a source or header file, so you can quickly jump back to the last accessed one by using <code>'C</code>
    or <code>'H</code> (see <code>:h 'A</code>).</p>
  <pre class="vim"><code>autocmd BufLeave *.{c,cpp} mark C
autocmd BufLeave *.h       mark H</code></pre>
  <p><strong>NOTE</strong>: The info is saved in the viminfo file, so make sure that <code>:set viminfo?</code> includes
    <code>:h viminfo-'</code>.</p>
  <h2 id="quickly-change-font-size-in-gui">Quickly change font size in GUI</h2>
  <p>I think this was taken from tpope’s config:</p>
  <pre
    class="vim"><code>command! Bigger  :let &amp;guifont = substitute(&amp;guifont, &#39;\d\+$&#39;, &#39;\=submatch(0)+1&#39;, &#39;&#39;)
command! Smaller :let &amp;guifont = substitute(&amp;guifont, &#39;\d\+$&#39;, &#39;\=submatch(0)-1&#39;, &#39;&#39;)</code></pre>
  <h2 id="change-cursor-style-dependent-on-mode">Change cursor style dependent on mode</h2>
  <p>I like to use a block cursor in normal mode, i-beam cursor in insert mode, and underline cursor in replace mode.
  </p>
  <pre class="vim"><code>if empty($TMUX)
  let &amp;t_SI = &quot;\&lt;Esc&gt;]50;CursorShape=1\x7&quot;
  let &amp;t_EI = &quot;\&lt;Esc&gt;]50;CursorShape=0\x7&quot;
  let &amp;t_SR = &quot;\&lt;Esc&gt;]50;CursorShape=2\x7&quot;
else
  let &amp;t_SI = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=1\x7\&lt;Esc&gt;\\&quot;
  let &amp;t_EI = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=0\x7\&lt;Esc&gt;\\&quot;
  let &amp;t_SR = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=2\x7\&lt;Esc&gt;\\&quot;
endif</code></pre>
  <p>This simply tells Vim to print a certain sequence of characters (<a
      href="https://en.wikipedia.org/wiki/Escape_sequence">escape sequence</a>) when entering/leaving insert mode. The
    underlying terminal, or programs like <a href="https://tmux.github.io">tmux</a> that sit between Vim and the
    terminal, will process and evaluate it.</p>
  <p>There’s one drawback though: there are many terminal emulator implementations and not all use the same sequences
    for doing the same things. The sequences used above might not work with your implementation. Your implementation
    might not even support different cursor styles. Check the documentation.</p>
  <p>The example above works with iTerm2.</p>
  <h2 id="dont-lose-selection-when-shifting-sidewards">Don’t lose selection when shifting sidewards</h2>
  <p>If you select one or more lines, you can use <code>&lt;</code> and <code>&gt;</code> for shifting them sidewards.
    Unfortunately you immediately lose the selection afterwards.</p>
  <p>You can use <code>gv</code> to reselect the last selection (see <code>:h gv</code>), thus you can work around it
    like this:</p>
  <pre class="vim"><code>xnoremap &lt;  &lt;gv
xnoremap &gt;  &gt;gv</code></pre>
  <p>Now you can use <code>&gt;&gt;&gt;&gt;&gt;</code> on your visual selection without any problems.</p>
  <p><strong>NOTE</strong>: The same can be achieved using <code>.</code>, which repeats the last change.</p>
  <h2 id="reload-a-file-on-saving">Reload a file on saving</h2>
  <p>Using <a href="#autocmds">autocmds</a> you can do anything on saving a file, e.g. sourcing it in case of a dotfile
    or running a linter to check for syntactical errors in your source code.</p>
  <pre class="vim"><code>autocmd BufWritePost $MYVIMRC source $MYVIMRC
autocmd BufWritePost ~/.Xdefaults call system(&#39;xrdb ~/.Xdefaults&#39;)</code></pre>
  <h2 id="smarter-cursorline">Smarter cursorline</h2>
  <p>I love the cursorline, but I only want to use it in the current window and not when being in insert mode:</p>
  <pre class="vim"><code>autocmd InsertLeave,WinEnter * set cursorline
autocmd InsertEnter,WinLeave * set nocursorline</code></pre>
  <h2 id="faster-keyword-completion">Faster keyword completion</h2>
  <p>The keyword completion (<code>&lt;c-n&gt;</code>/<code>&lt;c-p&gt;</code>) tries completing whatever is listed in
    the <code>'complete'</code> option. By default, this also includes tags (which can be annoying) and scanning all
    included files (which can be very slow). If you can live without these things, disable them:</p>
  <pre class="vim"><code>set complete-=i   &quot; disable scanning included files
set complete-=t   &quot; disable searching tags</code></pre>
  <h2 id="cosmetic-changes-to-colorschemes">Cosmetic changes to colorschemes</h2>
  <p>Always use a dark gray statusline, no matter what colorscheme is chosen:</p>
  <pre
    class="vim"><code>autocmd ColorScheme * highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE</code></pre>
  <p>This triggers every time you use <code>:colorscheme ...</code>. If you want it to trigger only for a certain
    colorscheme:</p>
  <pre
    class="vim"><code>autocmd ColorScheme desert highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE</code></pre>
  <p>This triggers only for <code>:colorscheme desert</code>.</p>
  <h1 id="commands-1">Commands</h1>
  <p>Useful commands that are good to know. Use <code>:h :&lt;command name&gt;</code> to learn more about them,
    e.g. <code>:h :global</code>.</p>
  <h2 id="global-and-vglobal">:global and :vglobal</h2>
  <p>Execute a command on all matching lines. E.g. <code>:global /regexp/ print</code> will use <code>:print</code> on
    all lines that contain “regexp”.</p>
  <p>Fun fact: You probably all know good old grep, the filter program written by Ken Thompson. What does it do? It
    prints all lines matching a certain regular expression! Now guess the short form of
    <code>:global /regexp/ print</code>? That’s right! It’s <code>:g/re/p</code>. Ken Thompson was inspired by vi’s
    <code>:global</code> when he wrote grep.</p>
  <p>Despite its name, <code>:global</code> only acts on all lines by default, but it also takes a range. Assume you
    want use <code>:delete</code> on all lines from the current line to the next blank line (matched by the regular
    expression <code>^$</code>) that contain “foo”:</p>
  <pre class="vim"><code>:,/^$/g/foo/d</code></pre>
  <p>For executing commands on all lines that do <em>not</em> match a given pattern, use <code>:global!</code> or its
    alias <code>:vglobal</code> (think <em>inVerse</em>) instead.</p>
  <h2 id="normal-and-execute">:normal and :execute</h2>
  <p>These commands are commonly used in Vim scripts.</p>
  <p>With <code>:normal</code> you can do normal mode mappings from the command-line. E.g. <code>:normal! 4j</code> will
    make the cursor go down 4 lines (without using any custom mapping for “j” due to the “!”).</p>
  <p>Mind that <code>:normal</code> also takes a <a href="#ranges">range</a>, so <code>:%norm! Iabc</code> would prepend
    “abc” to every line.</p>
  <p>With <code>:execute</code> you can mix commands with expressions. Assume you edit a C source file and want to
    switch to its header file:</p>
  <pre
    class="vim"><code>:execute &#39;edit&#39; fnamemodify(expand(&#39;%&#39;), &#39;:r&#39;) . &#39;.h&#39;</code></pre>
  <p>Both commands are often used together. Assume you want to make the cursor go down “n” lines:</p>
  <pre class="vim"><code>:let n = 4
:execute &#39;normal!&#39; n . &#39;j&#39;</code></pre>
  <h2 id="redir-and-execute">:redir and execute()</h2>
  <p>Many commands print messages and <code>:redir</code> allows to redirect that output. You can redirect to files, <a
      href="#registers">registers</a> or variables.</p>
  <pre class="vim"><code>:redir =&gt; var
:reg
:redir END
:echo var
:&quot; For fun let&#39;s also put it onto the current buffer.
:put =var</code></pre>
  <p>In Vim 8 there is an even shorter way:</p>
  <pre class="vim"><code>:put =execute(&#39;reg&#39;)</code></pre>
  <p>Help:</p>
  <pre><code>:h :redir
:h execute()</code></pre>
  <h1 id="debugging-1">Debugging</h1>
  <h2 id="general-tips">General tips</h2>
  <p>If you encounter a strange behaviour, try reproducing it like this:</p>
  <pre><code>vim -u NONE -N</code></pre>
  <p>This will start Vim without vimrc (thus default settings) and in nocompatible mode (which makes it use Vim defaults
    instead of vi defaults). (See <code>:h --noplugin</code> for other combinations of what to load at start.)</p>
  <p>If you can still reproduce it now, it’s most likely a bug in Vim itself! Report it to the <a
      href="https://groups.google.com/forum/#!forum/vim_dev">vim_dev</a> mailing list. Most of the time the issue won’t
    be resolved at this time and you’ll have to further investigate.</p>
  <p>Plugins often introduce new/changed/faulty behaviour. E.g. if it happens on saving, check
    <code>:verb au BufWritePost</code> to get a list of potential culprits.</p>
  <p>If you’re using a plugin manager, comment them out until you find the culprit.</p>
  <p>Issue is still not resolved? If it’s not a plugin, it must be your other settings, so maybe your options or
    autocmds etc.</p>
  <p>Time to use binary search. Repeatedly split the search space in two until you find the culprit line. Due to the
    nature of binary division, it won’t take many steps.</p>
  <p>In practice, it works like this: Put the <code>:finish</code> command in the middle of your vimrc. Vim will skip
    everything after it. If it still happens, the problem is in the active upper half. Move the <code>:finish</code> to
    the middle of <em>that</em> half. Otherwise, the issue is in the inactive lower half. Move the <code>:finish</code>
    to the middle of <em>that</em> half. And so on.</p>
  <h2 id="verbosity">Verbosity</h2>
  <p>Another useful way for observing what Vim is currently doing is increasing the verbosity level. Currently Vim
    supports 9 different levels. See <code>:h 'verbose'</code> for the full list.</p>
  <pre class="vim"><code>:e /tmp/foo
:set verbose=2
:w
:set verbose=0</code></pre>
  <p>This would show all the files that get sourced, e.g. the undo file or various plugins that act on saving.</p>
  <p>If you only want increase verbosity for a single command, there’s also <code>:verbose</code>, which simply gets put
    in front of any other command. It takes the verbosity level as count and defaults to 1:</p>
  <pre class="vim"><code>:verb set verbose
&quot;  verbose=1
:10verb set verbose
&quot;  verbose=10</code></pre>
  <p>It’s very often used with its default verbosity level 1 to show where an option was set last:</p>
  <pre class="vim"><code>:verb set ai?
&quot;      Last set from ~/.vim/vimrc</code></pre>
  <p>Naturally, the higher the verbosity level the more overwhelming the output. But fear no more, you can simply
    redirect the output to a file:</p>
  <pre class="vim"><code>:set verbosefile=/tmp/foo | 15verbose echo &quot;foo&quot; | vsplit /tmp/foo</code></pre>
  <p>You can also enable verbosity at starting time, with the <code>-V</code> option. It defaults to verbosity level 10.
    E.g. <code>vim -V5</code>.</p>
  <h2 id="profiling-startup-time">Profiling startup time</h2>
  <p>Vim startup feels slow? Time to crunch some numbers:</p>
  <pre><code>vim --startuptime /tmp/startup.log +q &amp;&amp; vim /tmp/startup.log</code></pre>
  <p>The first column is the most important as it shows the elapsed absolute time. If there is a big jump in time
    between two lines, the second line is either a very big file or a file with faulty VimL code that is worth
    investigating.</p>
  <h2 id="profiling-at-runtime">Profiling at runtime</h2>
  <p>Required <a href="#what-kind-of-vim-am-i-running">feature</a>: <code>+profile</code></p>
  <p>Vim provides a built-in capability for profiling at runtime and is a great way to find slow code in your
    environment.</p>
  <p>The <code>:profile</code> command takes a bunch of sub-commands for specifying what to profile.</p>
  <p>If you want to profile <em>everything</em>, do this:</p>
  <pre><code>:profile start /tmp/profile.log
:profile file *
:profile func *
&lt;do something in Vim&gt;
:qa</code></pre>
  <p>Vim keeps the profiling information in memory and only writes it out to the logfile on exit. (Neovim has fixed this
    using <code>:profile dump</code>).</p>
  <p>Have a look at <code>/tmp/profile.log</code>. All code that was executed during profiling will be shown. Every
    line, how often it was executed and how much time it took.</p>
  <p>Jump to the bottom of the log. Here are two different sections <code>FUNCTIONS SORTED ON TOTAL TIME</code> and
    <code>FUNCTIONS SORTED ON SELF TIME</code> that are worth gold. At a quick glance you can see which functions are
    taking the longest.</p>
  <p>You can use <code>:profile</code> during startup as well:</p>
  <pre><code>$ vim --cmd &#39;prof start prof.log | prof file * | prof func *&#39; test.c
:q
$ tail -50 prof.log</code></pre>
  <h2 id="debugging-vim-scripts">Debugging Vim scripts</h2>
  <p>If you ever used a command-line debugger before, <code>:debug</code> will quickly feel familiar.</p>
  <p>Simply prepend <code>:debug</code> to any other command and you’ll be put into debug mode. That is, the execution
    will stop at the first line about to be executed and that line will be displayed.</p>
  <p>See <code>:h &gt;cont</code> and below for the 6 available debugger commands and note that, like in gdb and similar
    debuggers, you can also use their short forms: <code>c</code>, <code>q</code>, <code>n</code>, <code>s</code>,
    <code>i</code>, and <code>f</code>.</p>
  <p>Apart from that those, you’re free to use any Vim command, e.g. <code>:echo myvar</code>, which gets executed in
    the context of the current position in the code.</p>
  <p>You basically get a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> by simply
    using <code>:debug 1</code>.</p>
  <p>It would be a pain if you had to single-step through every single line, so of course we can define breakpoints,
    too. (Breakpoints are called breakpoints, because the execution stops when they’re hit, thus you can simply skip
    code you’re not interested in.) See <code>:h :breakadd</code>, <code>:h :breakdel</code>, and
    <code>:h :breaklist</code> for further details.</p>
  <p>Let’s assume you want to know what code is run every time you save a file:</p>
  <pre class="vim"><code>:au BufWritePost
&quot; signify  BufWritePost
&quot;     *         call sy#start()
:breakadd func *start
:w
&quot; Breakpoint in &quot;sy#start&quot; line 1
&quot; Entering Debug mode.  Type &quot;cont&quot; to continue.
&quot; function sy#start
&quot; line 1: if g:signify_locked
&gt;s
&quot; function sy#start
&quot; line 3: endif
&gt;
&quot; function sy#start
&quot; line 5: let sy_path = resolve(expand(&#39;%:p&#39;))
&gt;q
:breakdel *</code></pre>
  <p>As you can see, using <code>&lt;cr&gt;</code> will repeat the previous debugger command, <code>s</code> in this
    case.</p>
  <p><code>:debug</code> can be used in combination with the <a href="#verbosity">verbose</a> option.</p>
  <h2 id="debugging-syntax-files">Debugging syntax files</h2>
  <p>Syntax files are often the cause for slowdowns due to wrong and/or complex regular expressions. If the
    <code>+profile</code> <a href="#what-kind-of-vim-am-i-running">feature</a> is compiled in, Vim provides the super
    useful <code>:syntime</code> command.</p>
  <pre class="vim"><code>:syntime on
&quot; hit &lt;c-l&gt; a few times to redraw the window which causes the syntax rules to get applied again
:syntime off
:syntime report</code></pre>
  <p>The output contains important metrics. E.g. you can see which regexp takes too long and should be optimized or
    which regexps are used all the time but never even match.</p>
  <p>See <code>:h :syntime</code>.</p>
  <h1 id="miscellaneous-1">Miscellaneous</h1>
  <h2 id="additional-resources">Additional resources</h2>
  <table>
    <colgroup>
      <col style="width: 43%" />
      <col style="width: 56%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Resource</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><a href="http://www.moolenaar.net/habits.html">Seven habits of effective text editing</a></td>
        <td>By Bram Moolenaar, the author of Vim.</td>
      </tr>
      <tr class="even">
        <td><a href="http://www.moolenaar.net/habits_2007.pdf">Seven habits of effective text editing 2.0 (PDF)</a></td>
        <td>See above.</td>
      </tr>
      <tr class="odd">
        <td><a
            href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp?sort_order=asc&amp;sort_by=Title&amp;search_by=scripting+the+vim+editor">IBM
            DeveloperWorks: Scripting the Vim editor</a></td>
        <td>Five-part series on Vim scripting.</td>
      </tr>
      <tr class="even">
        <td><a href="http://learnvimscriptthehardway.stevelosh.com">Learn Vimscript the Hard Way</a></td>
        <td>Develop a Vim plugin from scratch.</td>
      </tr>
      <tr class="odd">
        <td><a href="https://pragprog.com/titles/dnvim2/practical-vim-second-edition">Practical Vim (2nd Edition)</a>
        </td>
        <td>Hands down the best book about Vim.</td>
      </tr>
      <tr class="even">
        <td><a href="http://www.viemu.com/a-why-vi-vim.html">Why, oh WHY, do those #?@! nutheads use vi?</a></td>
        <td>Common misconceptions explained.</td>
      </tr>
      <tr class="odd">
        <td><a href="http://stackoverflow.com/a/1220118">Your problem with Vim is that you don’t grok vi</a></td>
        <td>Concise, informative and correct. A real gem.</td>
      </tr>
    </tbody>
  </table>
  <h4 id="screencasts">Screencasts</h4>
  <ul>
    <li><a href="http://vimcasts.org/episodes/archive">vimcasts.org</a></li>
    <li><a href="https://www.youtube.com/channel/UCXPHFM88IlFn68OmLwtPmZA">By wincent</a></li>
    <li><a href="http://derekwyatt.org/vim/tutorials/index.html">By Derek Wyatt</a></li>
  </ul>
  <h2 id="vim-distributions">Vim distributions</h2>
  <p>Vim distributions are bundles of custom settings and plugins for Vim.</p>
  <p>More advanced users know how to configure their editor anyway, so distributions are mostly targeted at beginners.
    If you think about that, it’s quite paradoxical though: Making it easier by adding even more things to learn about?
  </p>
  <p>I know that many people don’t want to spend hours and hours on customizing an editor (and actually you never stop
    customizing your vimrc when you finally got hooked), but eventually you only get efficient in Vim when you take the
    time to learn it properly.</p>
  <p>Repeat after me: “A programmer should know their tools.”</p>
  <p>Anyway, if you know what you’re doing, you might draw some inspiration from looking at a few distributions:</p>
  <ul>
    <li><a href="http://cream.sourceforge.net">cream</a></li>
    <li><a href="https://github.com/carlhuda/janus.git">janus</a></li>
    <li><a href="https://github.com/SpaceVim/SpaceVim">spacevim</a></li>
    <li><a href="https://github.com/spf13/spf13-vim">spf13</a></li>
  </ul>
  <h2 id="standard-plugins">Standard plugins</h2>
  <p>Many people are surprised by the fact that Vim comes with a handful of standard plugins. Some get loaded by default
    (<code>:e $VIMRUNTIME/plugin</code>) and some are not (<code>:e $VIMRUNTIME/pack/dist/opt</code>). Read
    <code>:h pack-add</code> on how to source the latter.</p>
  <p>Most of the plugins that get loaded by default will never get used, though. Disable them as you see fit. They will
    still be shown as sourced (<code>:scriptnames</code>), but only the first lines actually get read before Vim bails
    out. No further code (mappings, commands, logic) will be processed.</p>
  <table>
    <thead>
      <tr class="header">
        <th>Plugin</th>
        <th>Disable it using..</th>
        <th>Help</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td>2html</td>
        <td><code>let g:loaded_2html_plugin = 1</code></td>
        <td><code>:h 2html</code></td>
      </tr>
      <tr class="even">
        <td>getscript</td>
        <td><code>let g:loaded_getscriptPlugin = 1</code></td>
        <td><code>:h pi_getscript</code></td>
      </tr>
      <tr class="odd">
        <td>gzip</td>
        <td><code>let g:loaded_gzip = 1</code></td>
        <td><code>:h pi_gzip</code></td>
      </tr>
      <tr class="even">
        <td>logipat</td>
        <td><code>let g:loaded_logipat = 1</code></td>
        <td><code>:h pi_logipat</code></td>
      </tr>
      <tr class="odd">
        <td>matchparen</td>
        <td><code>let g:loaded_matchparen = 1</code></td>
        <td><code>:h pi_paren</code></td>
      </tr>
      <tr class="even">
        <td>netrw</td>
        <td><code>let g:loaded_netrwPlugin = 1</code></td>
        <td><code>:h pi_netrw</code></td>
      </tr>
      <tr class="odd">
        <td>rrhelper</td>
        <td><code>let g:loaded_rrhelper = 1</code></td>
        <td><code>:e $VIMRUNTIME/plugin/rrhelper.vim</code></td>
      </tr>
      <tr class="even">
        <td>spellfile</td>
        <td><code>let g:loaded_spellfile_plugin = 1</code></td>
        <td><code>:h spellfile.vim</code></td>
      </tr>
      <tr class="odd">
        <td>tar</td>
        <td><code>let g:loaded_tarPlugin = 1</code></td>
        <td><code>:h pi_tar</code></td>
      </tr>
      <tr class="even">
        <td>vimball</td>
        <td><code>let g:loaded_vimballPlugin = 1</code></td>
        <td><code>:h pi_vimball</code></td>
      </tr>
      <tr class="odd">
        <td>zip</td>
        <td><code>let g:loaded_zipPlugin = 1</code></td>
        <td><code>:h pi_zip</code></td>
      </tr>
    </tbody>
  </table>
  <h2 id="map-capslock-to-control">Map CapsLock to Control</h2>
  <p>CapsLock belongs to the most useless keys on your keyboard, but it’s much easier to reach than the Control key,
    since it lies on your <a
      href="https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-homerow.png">home row</a>.
    Mapping CapsLock to Control is a great way to prevent or at least reduce <a
      href="https://de.wikipedia.org/wiki/Repetitive-Strain-Injury-Syndrom">RSI</a> if you program a lot.</p>
  <p>Attention: When you get used to it, you can’t live without it anymore.</p>
  <p><strong>macOS</strong>:</p>
  <p><code>System Preferences -&gt; Keyboard -&gt; Keyboard Tab -&gt; Modifier Keys</code>. Change “CapsLock” to
    “Control”.</p>
  <p><strong>Linux</strong>:</p>
  <p>To change the keys in X, put this in your <code>~/.xmodmap</code>:</p>
  <pre><code>remove Lock = Caps_Lock
keysym Caps_Lock = Control_L
add Control = Control_L</code></pre>
  <p>Afterwards source it via <code>$ xmodmap ~/.xmodmap</code>.</p>
  <p>An alternative would be using <a href="https://github.com/oblitum/caps2esc">caps2esc</a> or <a
      href="https://github.com/alols/xcape">xcape</a>.</p>
  <p><strong>Windows</strong>:</p>
  <p>See <a href="http://superuser.com/questions/764782/map-caps-lock-to-control-in-windows-8-1">superuser.com: Map
      Caps-Lock to Control in Windows 8.1</a>.</p>
  <h2 id="generating-html-from-buffer">Generating HTML from buffer</h2>
  <p>Generate HTML from any buffer using <code>:TOhtml</code> from the 2html <a href="#standard-plugins">standard
      plugin</a>. The output can be used for printing or easy web publishing.</p>
  <p>The command creates a new buffer of the same name with <code>.html</code> appended. The colors are the same as seen
    in Vim. They depend on the <a href="#colorschemes">colorscheme</a>.</p>
  <p>The plugin knows several options to finetune the output, e.g. for setting the encoding and font.</p>
  <p>See <code>:h :TOhtml</code>.</p>
  <h2 id="easter-eggs">Easter eggs</h2>
  <table>
    <colgroup>
      <col style="width: 55%" />
      <col style="width: 45%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Command</th>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>:Ni!</code></td>
        <td><code>Do you demand a shrubbery?</code></td>
      </tr>
      <tr class="even">
        <td><code>:h 'sm'</code></td>
        <td><code>NOTE: Use of the short form is rated PG.</code></td>
      </tr>
      <tr class="odd">
        <td><code>:h 42</code></td>
        <td>
          <code>What is the meaning of life, the universe and everything? Douglas Adams, the only person who knew what this question really was about is now dead, unfortunately.  So now you might wonder what the meaning of death is...</code>
        </td>
      </tr>
      <tr class="even">
        <td><code>:h UserGettingBored</code></td>
        <td><code>When the user presses the same key 42 times. Just kidding! :-)</code></td>
      </tr>
      <tr class="odd">
        <td><code>:h bar</code></td>
        <td><code>Ceci n'est pas une pipe.</code></td>
      </tr>
      <tr class="even">
        <td><code>:h holy-grail</code></td>
        <td><code>You found it, Arthur!</code></td>
      </tr>
      <tr class="odd">
        <td><code>:h map-modes</code></td>
        <td><code>:nunmap can also be used outside of a monastery.</code></td>
      </tr>
      <tr class="even">
        <td><code>:help!</code></td>
        <td><code>E478: Don't panic!</code> (Glitch? When used in a help buffer (<code>buftype=help</code>) this works
          like <code>:h help.txt</code> instead.)</td>
      </tr>
      <tr class="odd">
        <td><code>:smile</code></td>
        <td>Try it out yourself. ;-) Added in 7.4.1005.</td>
      </tr>
      <tr class="even">
        <td><code>:hi!</code></td>
        <td><code>Greetings, Vim user!</code></td>
      </tr>
    </tbody>
  </table>
  <h2 id="why-hjkl-for-navigation">Why hjkl for navigation?</h2>
  <p>When <a href="https://en.wikipedia.org/wiki/Bill_Joy">Bill Joy</a> created <a
      href="https://en.wikipedia.org/wiki/Vi">vi</a>, a predecessor of Vim, he did it on a <a
      href="https://en.wikipedia.org/wiki/ADM-3A">ADM-3A</a> which had no extra cursor buttons but used, you might
    already guessed it, hjkl instead.</p>
  <p>Keyboard layout: <a
      href="https://raw.githubusercontent.com/mhinz/vim-galore/master/static/images/content-adm-3a-layout.jpg">click</a>
  </p>
  <p>This also shows why <code>~</code> is used to denote the home directory on Unix systems.</p>
  <h1 id="common-problems-1">Common problems</h1>
  <h2 id="editing-small-files-is-slow">Editing small files is slow</h2>
  <p>There are two things which can have a huge impact on performance:</p>
  <ol type="1">
    <li>Complex <strong>regular expressions</strong>. Particular the Ruby syntax file caused people to have slowdowns in
      the past. (Also see <a href="#debugging-syntax-files">Debugging syntax files</a>.)</li>
    <li><strong>Screen redraws</strong>. Some features force all lines to redraw.</li>
  </ol>
  <table>
    <colgroup>
      <col style="width: 50%" />
      <col style="width: 17%" />
      <col style="width: 32%" />
    </colgroup>
    <thead>
      <tr class="header">
        <th>Typical culprit</th>
        <th>Why?</th>
        <th>Solution?</th>
      </tr>
    </thead>
    <tbody>
      <tr class="odd">
        <td><code>:set cursorline</code></td>
        <td>Causes all lines to redraw.</td>
        <td><code>:set nocursorline</code></td>
      </tr>
      <tr class="even">
        <td><code>:set cursorcolumn</code></td>
        <td>Causes all lines to redraw.</td>
        <td><code>:set nocursorcolumn</code></td>
      </tr>
      <tr class="odd">
        <td><code>:set relativenumber</code></td>
        <td>Causes all lines to redraw.</td>
        <td><code>:set norelativenumber</code></td>
      </tr>
      <tr class="even">
        <td><code>:set foldmethod=syntax</code></td>
        <td>If the syntax file is slow already, this makes it even worse.</td>
        <td><code>:set foldmethod=manual</code>, <code>:set foldmethod=marker</code> or <a
            href="https://github.com/Konfekt/FastFold">FastFold</a></td>
      </tr>
      <tr class="odd">
        <td><code>:set synmaxcol=3000</code></td>
        <td>Due to internal representation, Vim has problems with long lines in general. Highlights columns till column
          3000.</td>
        <td><code>:set synmaxcol=200</code></td>
      </tr>
      <tr class="even">
        <td>matchparen.vim</td>
        <td>Loaded by default. Uses regular expressions to find the accompanying parenthesis.</td>
        <td>Disable plugin: <code>:h matchparen</code></td>
      </tr>
    </tbody>
  </table>
  <p><strong>NOTE</strong>: You only need to do this if you experience actual performance drawbacks. In most cases using
    the things mentioned above is absolutely fine.</p>
  <h2 id="editing-huge-files-is-slow">Editing huge files is slow</h2>
  <p>The biggest issue with big files is, that Vim reads the whole file at once. This is done due to how buffers are
    represented internally. (<a href="https://groups.google.com/forum/#!topic/vim_dev/oY3i8rqYGD4/discussion">Discussion
      on vim_dev@</a>)</p>
  <p>If you only want to read, <code>tail hugefile | vim -</code> is a good workaround.</p>
  <p>If you can live without syntax, settings and plugins for the moment:</p>
  <pre><code>$ vim -u NONE -N</code></pre>
  <p>This should make navigation quite a lot faster, especially since no expensive regular expressions for syntax
    highlighting are used. You should also tell Vim not to use swapfiles and viminfo files to avoid long delays on
    writing:</p>
  <pre><code>$ vim -n -u NONE -i NONE -N</code></pre>
  <p>Putting it in a nutshell, try to avoid using Vim when intending to write really huge files. :<br />
  </p>
  <h2 id="bracketed-paste-or-why-do-i-have-to-set-paste-all-the-time">Bracketed paste (or why do I have to set ‘paste’
    all the time?)</h2>
  <p>Bracketed paste mode allows terminal emulators to distinguish between typed text and pasted text.</p>
  <p>Did you ever tried pasting code into Vim and afterwards everything seemed messed up?</p>
  <p>This only happens if you paste via <code>cmd+v</code>, <code>shift-insert</code>, <code>middle-click</code> etc.
    because then you’re just throwing text at the terminal emulator. Vim doesn’t know that you just pasted the text, it
    thinks you’re an extremely fast typist. Accordingly, it tries to indent the lines and fails.</p>
  <p>Obviously this is not an issue, if you paste using Vim’s registers, e.g. <code>"+p</code>, because then Vim knows
    that you’re actually pasting.</p>
  <p>To workaround this, you have to <code>:set paste</code>, so it gets pasted as-is. See <code>:h 'paste'</code> and
    <code>:h 'pastetoggle'</code>.</p>
  <p>If you’re fed up with toggling <code>'paste'</code> all the time, have a look at this fine plugin that does it for
    you: <a href="https://github.com/ConradIrwin/vim-bracketed-paste">bracketed-paste</a>.</p>
  <p>Additional read from the same author as the plugin: <a href="http://cirw.in/blog/bracketed-paste">here</a>.</p>
  <p><strong>Neovim</strong>: Neovim tries to make all of this much more seamless and sets bracketed paste mode
    automatically if the terminal emulator supports it.</p>
  <h2 id="delays-when-using-escape-key-in-terminal">Delays when using escape key in terminal</h2>
  <p>If you live in the command-line, you probably use a so-called <em>terminal emulator</em> like xterm,
    gnome-terminal, iTerm2, etc. (opposed to a real <a
      href="https://en.wikipedia.org/wiki/Computer_terminal">terminal</a>).</p>
  <p>Like their ancestors, terminal emulators use <a href="https://en.wikipedia.org/wiki/Escape_sequence">escape
      sequences</a> (or <em>control sequences</em>) to control things like moving the cursor, changing text colors, etc.
    They’re simply strings of ASCII characters starting with an escape character (displayed in <a
      href="https://en.wikipedia.org/wiki/Caret_notation">caret notation</a> as <code>^[</code>). When such a string
    arrives, the terminal emulator looks up the accompanying action in the <a
      href="https://en.wikipedia.org/wiki/Terminfo">terminfo</a> database.</p>
  <p>To make the problem clearer, I’ll explain mapping timeouts first. They always happen when there’s ambiguity between
    mappings:</p>
  <pre class="vim"><code>:nnoremap ,a  :echo &#39;foo&#39;&lt;cr&gt;
:nnoremap ,ab :echo &#39;bar&#39;&lt;cr&gt;</code></pre>
  <p>Both mappings work as expected, but when typing <code>,a</code>, there will be a delay of 1 second, because Vim
    waits whether the user keys in another <code>b</code> or not.</p>
  <p>Escape sequences pose the same problem:</p>
  <ul>
    <li><code>&lt;esc&gt;</code> is used a lot for returning to normal mode or quitting an action.</li>
    <li>Cursor keys are encoded using escape sequences.</li>
    <li>Vim expects <kbd>Alt</kbd> (also called <em>Meta key</em>) to send a proper 8-bit encoding with the high bit
      set, but many terminal emulators don’t support it (or don’t enable it by default) and send an escape sequence
      instead.</li>
  </ul>
  <p>You can test the above like this: <code>vim -u NONE -N</code> and type <code>i&lt;c-v&gt;&lt;left&gt;</code> and
    you’ll see a sequence inserted that starts with <code>^[</code> which denotes the escape character.</p>
  <p>Putting it in a nutshell, Vim has a hard time distinguishing between a typed <code>&lt;esc&gt;</code> character and
    a proper escape sequence.</p>
  <p>By default, Vim uses <code>:set timeout timeoutlen=1000</code>, so it delays on ambiguity of mappings <em>and</em>
    key codes by 1 second. This is a sane value for mappings, but you can define the key code timeout on its own which
    is the most common workaround for this entire issue:</p>
  <pre class="vim"><code>set timeout           &quot; for mappings
set timeoutlen=1000   &quot; default value
set ttimeout          &quot; for key codes
set ttimeoutlen=10    &quot; unnoticeable small value</code></pre>
  <p>Under <code>:h ttimeout</code> you find a small table showing the relationship between these options.</p>
  <p>If you’re using tmux between Vim and your terminal emulator, also put this in your <code>~/.tmux.conf</code>:</p>
  <pre class="tmux"><code>set -sg escape-time 0</code></pre>
  <h2 id="function-search-undo">Function search undo</h2>
  <ul>
    <li>A search pattern in a command (<code>/</code>, <code>:substitute</code>, …) changes the “last used search
      pattern”. (It’s saved in the <code>/</code> register; print it with <code>:echo @/</code>).</li>
    <li>A simple text change can be redone with <code>.</code>. (It’s saved in the <code>.</code> register; print it
      with <code>:echo @.</code>).</li>
  </ul>
  <p>Both things are <em>not</em> the case, if you do them from a function, though! Thus you can’t easily highlight
    words from a function or redo the text changes made by it.</p>
  <p>Help: <code>:h function-search-undo</code></p>
  <h1 id="technical-quirks-1">Technical quirks</h1>
  <h2 id="newline-used-for-nul">Newline used for NUL</h2>
  <p>NUL characters (<code>\0</code>) in a file, are stored as newline (<code>\n</code>) in memory and displayed in a
    buffer as <code>^@</code>.</p>
  <p>See <code>man 7 ascii</code> and <code>:h NL-used-for-Nul</code> for more information.</p>
  <h1 id="terminology-1">Terminology</h1>
  <h2 id="vim-script-vimscript-viml">Vim script? Vimscript? VimL?</h2>
  <p><code>Vim script</code>, <code>Vimscript</code>, and <code>VimL</code> all refer to the same thing: The programming
    language used for scripting Vim. Even though <a
      href="https://github.com/vim/vim/commit/b544f3c81f1e6a50322855681ac266ffaa8e313c">8.0.360</a> changed all
    references from <code>VimL</code> to <code>Vim script</code>, which can now be considered the official term,
    <code>VimL</code> is still widespread all over the internet.</p>
  <p>No matter which term you use, everyone will understand it.</p>
</body>

</html>
